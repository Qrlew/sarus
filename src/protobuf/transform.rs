// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `sarus_data_spec/protobuf/transform.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:Transform)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Transform {
    // message fields
    // @@protoc_insertion_point(field:Transform.uuid)
    pub uuid: ::std::string::String,
    // @@protoc_insertion_point(field:Transform.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:Transform.doc)
    pub doc: ::std::string::String,
    // @@protoc_insertion_point(field:Transform.spec)
    pub spec: ::protobuf::MessageField<transform::Spec>,
    // @@protoc_insertion_point(field:Transform.properties)
    pub properties: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:Transform.inversible)
    pub inversible: bool,
    // @@protoc_insertion_point(field:Transform.schema_preserving)
    pub schema_preserving: bool,
    // special fields
    // @@protoc_insertion_point(special_field:Transform.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Transform {
    fn default() -> &'a Transform {
        <Transform as ::protobuf::Message>::default_instance()
    }
}

impl Transform {
    pub fn new() -> Transform {
        ::std::default::Default::default()
    }

    // string uuid = 1;

    pub fn uuid(&self) -> &str {
        &self.uuid
    }

    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::string::String) {
        self.uuid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::string::String {
        &mut self.uuid
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uuid, ::std::string::String::new())
    }

    // string name = 2;

    pub fn name(&self) -> &str {
        &self.name
    }

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string doc = 3;

    pub fn doc(&self) -> &str {
        &self.doc
    }

    pub fn clear_doc(&mut self) {
        self.doc.clear();
    }

    // Param is passed by value, moved
    pub fn set_doc(&mut self, v: ::std::string::String) {
        self.doc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc(&mut self) -> &mut ::std::string::String {
        &mut self.doc
    }

    // Take field
    pub fn take_doc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.doc, ::std::string::String::new())
    }

    // .Transform.Spec spec = 4;

    pub fn spec(&self) -> &transform::Spec {
        self.spec.as_ref().unwrap_or_else(|| <transform::Spec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: transform::Spec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut transform::Spec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> transform::Spec {
        self.spec.take().unwrap_or_else(|| transform::Spec::new())
    }

    // repeated .Transform.PropertiesEntry properties = 5;

    pub fn properties(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.properties
    }

    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.properties, ::std::collections::HashMap::new())
    }

    // bool inversible = 6;

    pub fn inversible(&self) -> bool {
        self.inversible
    }

    pub fn clear_inversible(&mut self) {
        self.inversible = false;
    }

    // Param is passed by value, moved
    pub fn set_inversible(&mut self, v: bool) {
        self.inversible = v;
    }

    // bool schema_preserving = 7;

    pub fn schema_preserving(&self) -> bool {
        self.schema_preserving
    }

    pub fn clear_schema_preserving(&mut self) {
        self.schema_preserving = false;
    }

    // Param is passed by value, moved
    pub fn set_schema_preserving(&mut self, v: bool) {
        self.schema_preserving = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uuid",
            |m: &Transform| { &m.uuid },
            |m: &mut Transform| { &mut m.uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Transform| { &m.name },
            |m: &mut Transform| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "doc",
            |m: &Transform| { &m.doc },
            |m: &mut Transform| { &mut m.doc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, transform::Spec>(
            "spec",
            |m: &Transform| { &m.spec },
            |m: &mut Transform| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "properties",
            |m: &Transform| { &m.properties },
            |m: &mut Transform| { &mut m.properties },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inversible",
            |m: &Transform| { &m.inversible },
            |m: &mut Transform| { &mut m.inversible },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "schema_preserving",
            |m: &Transform| { &m.schema_preserving },
            |m: &mut Transform| { &mut m.schema_preserving },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Transform>(
            "Transform",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Transform {
    const NAME: &'static str = "Transform";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uuid = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.doc = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.properties.insert(key, value);
                },
                48 => {
                    self.inversible = is.read_bool()?;
                },
                56 => {
                    self.schema_preserving = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uuid);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.doc.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.doc);
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.properties {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if self.inversible != false {
            my_size += 1 + 1;
        }
        if self.schema_preserving != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.uuid.is_empty() {
            os.write_string(1, &self.uuid)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.doc.is_empty() {
            os.write_string(3, &self.doc)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for (k, v) in &self.properties {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if self.inversible != false {
            os.write_bool(6, self.inversible)?;
        }
        if self.schema_preserving != false {
            os.write_bool(7, self.schema_preserving)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Transform {
        Transform::new()
    }

    fn clear(&mut self) {
        self.uuid.clear();
        self.name.clear();
        self.doc.clear();
        self.spec.clear();
        self.properties.clear();
        self.inversible = false;
        self.schema_preserving = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Transform {
        static instance: ::protobuf::rt::Lazy<Transform> = ::protobuf::rt::Lazy::new();
        instance.get(Transform::new)
    }
}

impl ::protobuf::MessageFull for Transform {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Transform").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Transform {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transform {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Transform`
pub mod transform {
    // @@protoc_insertion_point(message:Transform.Spec)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Spec {
        // message oneof groups
        pub spec: ::std::option::Option<spec::Spec>,
        // special fields
        // @@protoc_insertion_point(special_field:Transform.Spec.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Spec {
        fn default() -> &'a Spec {
            <Spec as ::protobuf::Message>::default_instance()
        }
    }

    impl Spec {
        pub fn new() -> Spec {
            ::std::default::Default::default()
        }

        // .Transform.Identity identity = 1;

        pub fn identity(&self) -> &Identity {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Identity(ref v)) => v,
                _ => <Identity as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_identity(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_identity(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Identity(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_identity(&mut self, v: Identity) {
            self.spec = ::std::option::Option::Some(spec::Spec::Identity(v))
        }

        // Mutable pointer to the field.
        pub fn mut_identity(&mut self) -> &mut Identity {
            if let ::std::option::Option::Some(spec::Spec::Identity(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::Identity(Identity::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Identity(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_identity(&mut self) -> Identity {
            if self.has_identity() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::Identity(v)) => v,
                    _ => panic!(),
                }
            } else {
                Identity::new()
            }
        }

        // .Transform.Variable variable = 2;

        pub fn variable(&self) -> &Variable {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Variable(ref v)) => v,
                _ => <Variable as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_variable(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_variable(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Variable(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_variable(&mut self, v: Variable) {
            self.spec = ::std::option::Option::Some(spec::Spec::Variable(v))
        }

        // Mutable pointer to the field.
        pub fn mut_variable(&mut self) -> &mut Variable {
            if let ::std::option::Option::Some(spec::Spec::Variable(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::Variable(Variable::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Variable(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_variable(&mut self) -> Variable {
            if self.has_variable() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::Variable(v)) => v,
                    _ => panic!(),
                }
            } else {
                Variable::new()
            }
        }

        // .Transform.Composed composed = 3;

        pub fn composed(&self) -> &Composed {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Composed(ref v)) => v,
                _ => <Composed as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_composed(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_composed(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Composed(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_composed(&mut self, v: Composed) {
            self.spec = ::std::option::Option::Some(spec::Spec::Composed(v))
        }

        // Mutable pointer to the field.
        pub fn mut_composed(&mut self) -> &mut Composed {
            if let ::std::option::Option::Some(spec::Spec::Composed(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::Composed(Composed::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Composed(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_composed(&mut self) -> Composed {
            if self.has_composed() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::Composed(v)) => v,
                    _ => panic!(),
                }
            } else {
                Composed::new()
            }
        }

        // .Transform.Project project = 4;

        pub fn project(&self) -> &Project {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Project(ref v)) => v,
                _ => <Project as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_project(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_project(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Project(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_project(&mut self, v: Project) {
            self.spec = ::std::option::Option::Some(spec::Spec::Project(v))
        }

        // Mutable pointer to the field.
        pub fn mut_project(&mut self) -> &mut Project {
            if let ::std::option::Option::Some(spec::Spec::Project(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::Project(Project::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Project(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_project(&mut self) -> Project {
            if self.has_project() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::Project(v)) => v,
                    _ => panic!(),
                }
            } else {
                Project::new()
            }
        }

        // .Transform.Filter filter = 5;

        pub fn filter(&self) -> &Filter {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Filter(ref v)) => v,
                _ => <Filter as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_filter(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_filter(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Filter(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_filter(&mut self, v: Filter) {
            self.spec = ::std::option::Option::Some(spec::Spec::Filter(v))
        }

        // Mutable pointer to the field.
        pub fn mut_filter(&mut self) -> &mut Filter {
            if let ::std::option::Option::Some(spec::Spec::Filter(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::Filter(Filter::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Filter(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_filter(&mut self) -> Filter {
            if self.has_filter() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::Filter(v)) => v,
                    _ => panic!(),
                }
            } else {
                Filter::new()
            }
        }

        // .Transform.Shuffle shuffle = 6;

        pub fn shuffle(&self) -> &Shuffle {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Shuffle(ref v)) => v,
                _ => <Shuffle as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_shuffle(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_shuffle(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Shuffle(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_shuffle(&mut self, v: Shuffle) {
            self.spec = ::std::option::Option::Some(spec::Spec::Shuffle(v))
        }

        // Mutable pointer to the field.
        pub fn mut_shuffle(&mut self) -> &mut Shuffle {
            if let ::std::option::Option::Some(spec::Spec::Shuffle(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::Shuffle(Shuffle::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Shuffle(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_shuffle(&mut self) -> Shuffle {
            if self.has_shuffle() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::Shuffle(v)) => v,
                    _ => panic!(),
                }
            } else {
                Shuffle::new()
            }
        }

        // .Transform.Join join = 7;

        pub fn join(&self) -> &Join {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Join(ref v)) => v,
                _ => <Join as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_join(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_join(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Join(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_join(&mut self, v: Join) {
            self.spec = ::std::option::Option::Some(spec::Spec::Join(v))
        }

        // Mutable pointer to the field.
        pub fn mut_join(&mut self) -> &mut Join {
            if let ::std::option::Option::Some(spec::Spec::Join(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::Join(Join::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Join(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_join(&mut self) -> Join {
            if self.has_join() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::Join(v)) => v,
                    _ => panic!(),
                }
            } else {
                Join::new()
            }
        }

        // .Transform.Cast cast = 8;

        pub fn cast(&self) -> &Cast {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Cast(ref v)) => v,
                _ => <Cast as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_cast(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_cast(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Cast(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_cast(&mut self, v: Cast) {
            self.spec = ::std::option::Option::Some(spec::Spec::Cast(v))
        }

        // Mutable pointer to the field.
        pub fn mut_cast(&mut self) -> &mut Cast {
            if let ::std::option::Option::Some(spec::Spec::Cast(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::Cast(Cast::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Cast(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_cast(&mut self) -> Cast {
            if self.has_cast() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::Cast(v)) => v,
                    _ => panic!(),
                }
            } else {
                Cast::new()
            }
        }

        // .Transform.Sample sample = 9;

        pub fn sample(&self) -> &Sample {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Sample(ref v)) => v,
                _ => <Sample as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_sample(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_sample(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Sample(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_sample(&mut self, v: Sample) {
            self.spec = ::std::option::Option::Some(spec::Spec::Sample(v))
        }

        // Mutable pointer to the field.
        pub fn mut_sample(&mut self) -> &mut Sample {
            if let ::std::option::Option::Some(spec::Spec::Sample(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::Sample(Sample::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Sample(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_sample(&mut self) -> Sample {
            if self.has_sample() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::Sample(v)) => v,
                    _ => panic!(),
                }
            } else {
                Sample::new()
            }
        }

        // .Transform.UserSettings user_settings = 10;

        pub fn user_settings(&self) -> &UserSettings {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::UserSettings(ref v)) => v,
                _ => <UserSettings as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_user_settings(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_user_settings(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::UserSettings(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_user_settings(&mut self, v: UserSettings) {
            self.spec = ::std::option::Option::Some(spec::Spec::UserSettings(v))
        }

        // Mutable pointer to the field.
        pub fn mut_user_settings(&mut self) -> &mut UserSettings {
            if let ::std::option::Option::Some(spec::Spec::UserSettings(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::UserSettings(UserSettings::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::UserSettings(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_user_settings(&mut self) -> UserSettings {
            if self.has_user_settings() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::UserSettings(v)) => v,
                    _ => panic!(),
                }
            } else {
                UserSettings::new()
            }
        }

        // .Transform.Protect protect_dataset = 11;

        pub fn protect_dataset(&self) -> &Protect {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::ProtectDataset(ref v)) => v,
                _ => <Protect as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_protect_dataset(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_protect_dataset(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::ProtectDataset(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_protect_dataset(&mut self, v: Protect) {
            self.spec = ::std::option::Option::Some(spec::Spec::ProtectDataset(v))
        }

        // Mutable pointer to the field.
        pub fn mut_protect_dataset(&mut self) -> &mut Protect {
            if let ::std::option::Option::Some(spec::Spec::ProtectDataset(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::ProtectDataset(Protect::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::ProtectDataset(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_protect_dataset(&mut self) -> Protect {
            if self.has_protect_dataset() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::ProtectDataset(v)) => v,
                    _ => panic!(),
                }
            } else {
                Protect::new()
            }
        }

        // .Transform.External external = 12;

        pub fn external(&self) -> &External {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::External(ref v)) => v,
                _ => <External as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_external(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_external(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::External(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_external(&mut self, v: External) {
            self.spec = ::std::option::Option::Some(spec::Spec::External(v))
        }

        // Mutable pointer to the field.
        pub fn mut_external(&mut self) -> &mut External {
            if let ::std::option::Option::Some(spec::Spec::External(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::External(External::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::External(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_external(&mut self) -> External {
            if self.has_external() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::External(v)) => v,
                    _ => panic!(),
                }
            } else {
                External::new()
            }
        }

        // .Transform.Synthetic synthetic = 13;

        pub fn synthetic(&self) -> &Synthetic {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Synthetic(ref v)) => v,
                _ => <Synthetic as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_synthetic(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_synthetic(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Synthetic(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_synthetic(&mut self, v: Synthetic) {
            self.spec = ::std::option::Option::Some(spec::Spec::Synthetic(v))
        }

        // Mutable pointer to the field.
        pub fn mut_synthetic(&mut self) -> &mut Synthetic {
            if let ::std::option::Option::Some(spec::Spec::Synthetic(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::Synthetic(Synthetic::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Synthetic(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_synthetic(&mut self) -> Synthetic {
            if self.has_synthetic() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::Synthetic(v)) => v,
                    _ => panic!(),
                }
            } else {
                Synthetic::new()
            }
        }

        // .Transform.Transcode transcode = 14;

        pub fn transcode(&self) -> &Transcode {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Transcode(ref v)) => v,
                _ => <Transcode as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_transcode(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_transcode(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Transcode(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_transcode(&mut self, v: Transcode) {
            self.spec = ::std::option::Option::Some(spec::Spec::Transcode(v))
        }

        // Mutable pointer to the field.
        pub fn mut_transcode(&mut self) -> &mut Transcode {
            if let ::std::option::Option::Some(spec::Spec::Transcode(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::Transcode(Transcode::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Transcode(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_transcode(&mut self) -> Transcode {
            if self.has_transcode() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::Transcode(v)) => v,
                    _ => panic!(),
                }
            } else {
                Transcode::new()
            }
        }

        // .Transform.InverseTranscode inverse_transcode = 15;

        pub fn inverse_transcode(&self) -> &InverseTranscode {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::InverseTranscode(ref v)) => v,
                _ => <InverseTranscode as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_inverse_transcode(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_inverse_transcode(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::InverseTranscode(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_inverse_transcode(&mut self, v: InverseTranscode) {
            self.spec = ::std::option::Option::Some(spec::Spec::InverseTranscode(v))
        }

        // Mutable pointer to the field.
        pub fn mut_inverse_transcode(&mut self) -> &mut InverseTranscode {
            if let ::std::option::Option::Some(spec::Spec::InverseTranscode(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::InverseTranscode(InverseTranscode::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::InverseTranscode(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_inverse_transcode(&mut self) -> InverseTranscode {
            if self.has_inverse_transcode() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::InverseTranscode(v)) => v,
                    _ => panic!(),
                }
            } else {
                InverseTranscode::new()
            }
        }

        // .Transform.GetItem get_item = 16;

        pub fn get_item(&self) -> &GetItem {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::GetItem(ref v)) => v,
                _ => <GetItem as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_get_item(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_get_item(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::GetItem(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_get_item(&mut self, v: GetItem) {
            self.spec = ::std::option::Option::Some(spec::Spec::GetItem(v))
        }

        // Mutable pointer to the field.
        pub fn mut_get_item(&mut self) -> &mut GetItem {
            if let ::std::option::Option::Some(spec::Spec::GetItem(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::GetItem(GetItem::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::GetItem(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_get_item(&mut self) -> GetItem {
            if self.has_get_item() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::GetItem(v)) => v,
                    _ => panic!(),
                }
            } else {
                GetItem::new()
            }
        }

        // .Transform.ProtectedPaths protected_paths = 17;

        pub fn protected_paths(&self) -> &ProtectedPaths {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::ProtectedPaths(ref v)) => v,
                _ => <ProtectedPaths as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_protected_paths(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_protected_paths(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::ProtectedPaths(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_protected_paths(&mut self, v: ProtectedPaths) {
            self.spec = ::std::option::Option::Some(spec::Spec::ProtectedPaths(v))
        }

        // Mutable pointer to the field.
        pub fn mut_protected_paths(&mut self) -> &mut ProtectedPaths {
            if let ::std::option::Option::Some(spec::Spec::ProtectedPaths(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::ProtectedPaths(ProtectedPaths::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::ProtectedPaths(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_protected_paths(&mut self) -> ProtectedPaths {
            if self.has_protected_paths() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::ProtectedPaths(v)) => v,
                    _ => panic!(),
                }
            } else {
                ProtectedPaths::new()
            }
        }

        // .Transform.AutomaticUserSettings automatic_user_settings = 18;

        pub fn automatic_user_settings(&self) -> &AutomaticUserSettings {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::AutomaticUserSettings(ref v)) => v,
                _ => <AutomaticUserSettings as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_automatic_user_settings(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_automatic_user_settings(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::AutomaticUserSettings(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_automatic_user_settings(&mut self, v: AutomaticUserSettings) {
            self.spec = ::std::option::Option::Some(spec::Spec::AutomaticUserSettings(v))
        }

        // Mutable pointer to the field.
        pub fn mut_automatic_user_settings(&mut self) -> &mut AutomaticUserSettings {
            if let ::std::option::Option::Some(spec::Spec::AutomaticUserSettings(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::AutomaticUserSettings(AutomaticUserSettings::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::AutomaticUserSettings(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_automatic_user_settings(&mut self) -> AutomaticUserSettings {
            if self.has_automatic_user_settings() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::AutomaticUserSettings(v)) => v,
                    _ => panic!(),
                }
            } else {
                AutomaticUserSettings::new()
            }
        }

        // .Transform.PublicPaths public_paths = 19;

        pub fn public_paths(&self) -> &PublicPaths {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::PublicPaths(ref v)) => v,
                _ => <PublicPaths as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_public_paths(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_public_paths(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::PublicPaths(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_public_paths(&mut self, v: PublicPaths) {
            self.spec = ::std::option::Option::Some(spec::Spec::PublicPaths(v))
        }

        // Mutable pointer to the field.
        pub fn mut_public_paths(&mut self) -> &mut PublicPaths {
            if let ::std::option::Option::Some(spec::Spec::PublicPaths(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::PublicPaths(PublicPaths::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::PublicPaths(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_public_paths(&mut self) -> PublicPaths {
            if self.has_public_paths() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::PublicPaths(v)) => v,
                    _ => panic!(),
                }
            } else {
                PublicPaths::new()
            }
        }

        // .Transform.AssignBudget assign_budget = 20;

        pub fn assign_budget(&self) -> &AssignBudget {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::AssignBudget(ref v)) => v,
                _ => <AssignBudget as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_assign_budget(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_assign_budget(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::AssignBudget(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_assign_budget(&mut self, v: AssignBudget) {
            self.spec = ::std::option::Option::Some(spec::Spec::AssignBudget(v))
        }

        // Mutable pointer to the field.
        pub fn mut_assign_budget(&mut self) -> &mut AssignBudget {
            if let ::std::option::Option::Some(spec::Spec::AssignBudget(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::AssignBudget(AssignBudget::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::AssignBudget(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_assign_budget(&mut self) -> AssignBudget {
            if self.has_assign_budget() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::AssignBudget(v)) => v,
                    _ => panic!(),
                }
            } else {
                AssignBudget::new()
            }
        }

        // .Transform.AutomaticBudget automatic_budget = 21;

        pub fn automatic_budget(&self) -> &AutomaticBudget {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::AutomaticBudget(ref v)) => v,
                _ => <AutomaticBudget as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_automatic_budget(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_automatic_budget(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::AutomaticBudget(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_automatic_budget(&mut self, v: AutomaticBudget) {
            self.spec = ::std::option::Option::Some(spec::Spec::AutomaticBudget(v))
        }

        // Mutable pointer to the field.
        pub fn mut_automatic_budget(&mut self) -> &mut AutomaticBudget {
            if let ::std::option::Option::Some(spec::Spec::AutomaticBudget(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::AutomaticBudget(AutomaticBudget::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::AutomaticBudget(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_automatic_budget(&mut self) -> AutomaticBudget {
            if self.has_automatic_budget() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::AutomaticBudget(v)) => v,
                    _ => panic!(),
                }
            } else {
                AutomaticBudget::new()
            }
        }

        // .Transform.AttributesBudget attribute_budget = 22;

        pub fn attribute_budget(&self) -> &AttributesBudget {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::AttributeBudget(ref v)) => v,
                _ => <AttributesBudget as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_attribute_budget(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_attribute_budget(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::AttributeBudget(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_attribute_budget(&mut self, v: AttributesBudget) {
            self.spec = ::std::option::Option::Some(spec::Spec::AttributeBudget(v))
        }

        // Mutable pointer to the field.
        pub fn mut_attribute_budget(&mut self) -> &mut AttributesBudget {
            if let ::std::option::Option::Some(spec::Spec::AttributeBudget(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::AttributeBudget(AttributesBudget::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::AttributeBudget(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_attribute_budget(&mut self) -> AttributesBudget {
            if self.has_attribute_budget() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::AttributeBudget(v)) => v,
                    _ => panic!(),
                }
            } else {
                AttributesBudget::new()
            }
        }

        // .Transform.SDBudget sd_budget = 23;

        pub fn sd_budget(&self) -> &SDBudget {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::SdBudget(ref v)) => v,
                _ => <SDBudget as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_sd_budget(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_sd_budget(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::SdBudget(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_sd_budget(&mut self, v: SDBudget) {
            self.spec = ::std::option::Option::Some(spec::Spec::SdBudget(v))
        }

        // Mutable pointer to the field.
        pub fn mut_sd_budget(&mut self) -> &mut SDBudget {
            if let ::std::option::Option::Some(spec::Spec::SdBudget(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::SdBudget(SDBudget::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::SdBudget(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_sd_budget(&mut self) -> SDBudget {
            if self.has_sd_budget() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::SdBudget(v)) => v,
                    _ => panic!(),
                }
            } else {
                SDBudget::new()
            }
        }

        // .Transform.DeriveSeed derive_seed = 24;

        pub fn derive_seed(&self) -> &DeriveSeed {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::DeriveSeed(ref v)) => v,
                _ => <DeriveSeed as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_derive_seed(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_derive_seed(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::DeriveSeed(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_derive_seed(&mut self, v: DeriveSeed) {
            self.spec = ::std::option::Option::Some(spec::Spec::DeriveSeed(v))
        }

        // Mutable pointer to the field.
        pub fn mut_derive_seed(&mut self) -> &mut DeriveSeed {
            if let ::std::option::Option::Some(spec::Spec::DeriveSeed(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::DeriveSeed(DeriveSeed::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::DeriveSeed(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_derive_seed(&mut self) -> DeriveSeed {
            if self.has_derive_seed() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::DeriveSeed(v)) => v,
                    _ => panic!(),
                }
            } else {
                DeriveSeed::new()
            }
        }

        // .Transform.GroupByPE group_by_pe = 25;

        pub fn group_by_pe(&self) -> &GroupByPE {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::GroupByPe(ref v)) => v,
                _ => <GroupByPE as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_group_by_pe(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_group_by_pe(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::GroupByPe(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_group_by_pe(&mut self, v: GroupByPE) {
            self.spec = ::std::option::Option::Some(spec::Spec::GroupByPe(v))
        }

        // Mutable pointer to the field.
        pub fn mut_group_by_pe(&mut self) -> &mut GroupByPE {
            if let ::std::option::Option::Some(spec::Spec::GroupByPe(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::GroupByPe(GroupByPE::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::GroupByPe(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_group_by_pe(&mut self) -> GroupByPE {
            if self.has_group_by_pe() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::GroupByPe(v)) => v,
                    _ => panic!(),
                }
            } else {
                GroupByPE::new()
            }
        }

        // .Transform.SamplingRatios sampling_ratios = 26;

        pub fn sampling_ratios(&self) -> &SamplingRatios {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::SamplingRatios(ref v)) => v,
                _ => <SamplingRatios as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_sampling_ratios(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_sampling_ratios(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::SamplingRatios(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_sampling_ratios(&mut self, v: SamplingRatios) {
            self.spec = ::std::option::Option::Some(spec::Spec::SamplingRatios(v))
        }

        // Mutable pointer to the field.
        pub fn mut_sampling_ratios(&mut self) -> &mut SamplingRatios {
            if let ::std::option::Option::Some(spec::Spec::SamplingRatios(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::SamplingRatios(SamplingRatios::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::SamplingRatios(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_sampling_ratios(&mut self) -> SamplingRatios {
            if self.has_sampling_ratios() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::SamplingRatios(v)) => v,
                    _ => panic!(),
                }
            } else {
                SamplingRatios::new()
            }
        }

        // .Transform.SelectSql select_sql = 27;

        pub fn select_sql(&self) -> &SelectSql {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::SelectSql(ref v)) => v,
                _ => <SelectSql as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_select_sql(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_select_sql(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::SelectSql(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_select_sql(&mut self, v: SelectSql) {
            self.spec = ::std::option::Option::Some(spec::Spec::SelectSql(v))
        }

        // Mutable pointer to the field.
        pub fn mut_select_sql(&mut self) -> &mut SelectSql {
            if let ::std::option::Option::Some(spec::Spec::SelectSql(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::SelectSql(SelectSql::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::SelectSql(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_select_sql(&mut self) -> SelectSql {
            if self.has_select_sql() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::SelectSql(v)) => v,
                    _ => panic!(),
                }
            } else {
                SelectSql::new()
            }
        }

        // .Transform.Extract extract = 28;

        pub fn extract(&self) -> &Extract {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Extract(ref v)) => v,
                _ => <Extract as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_extract(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_extract(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Extract(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_extract(&mut self, v: Extract) {
            self.spec = ::std::option::Option::Some(spec::Spec::Extract(v))
        }

        // Mutable pointer to the field.
        pub fn mut_extract(&mut self) -> &mut Extract {
            if let ::std::option::Option::Some(spec::Spec::Extract(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::Extract(Extract::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::Extract(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_extract(&mut self) -> Extract {
            if self.has_extract() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::Extract(v)) => v,
                    _ => panic!(),
                }
            } else {
                Extract::new()
            }
        }

        // .Transform.RelationshipSpec relationship_spec = 29;

        pub fn relationship_spec(&self) -> &RelationshipSpec {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::RelationshipSpec(ref v)) => v,
                _ => <RelationshipSpec as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_relationship_spec(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_relationship_spec(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::RelationshipSpec(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_relationship_spec(&mut self, v: RelationshipSpec) {
            self.spec = ::std::option::Option::Some(spec::Spec::RelationshipSpec(v))
        }

        // Mutable pointer to the field.
        pub fn mut_relationship_spec(&mut self) -> &mut RelationshipSpec {
            if let ::std::option::Option::Some(spec::Spec::RelationshipSpec(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::RelationshipSpec(RelationshipSpec::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::RelationshipSpec(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_relationship_spec(&mut self) -> RelationshipSpec {
            if self.has_relationship_spec() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::RelationshipSpec(v)) => v,
                    _ => panic!(),
                }
            } else {
                RelationshipSpec::new()
            }
        }

        // .Transform.DifferentiatedSample differentiated_sample = 30;

        pub fn differentiated_sample(&self) -> &DifferentiatedSample {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::DifferentiatedSample(ref v)) => v,
                _ => <DifferentiatedSample as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_differentiated_sample(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_differentiated_sample(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::DifferentiatedSample(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_differentiated_sample(&mut self, v: DifferentiatedSample) {
            self.spec = ::std::option::Option::Some(spec::Spec::DifferentiatedSample(v))
        }

        // Mutable pointer to the field.
        pub fn mut_differentiated_sample(&mut self) -> &mut DifferentiatedSample {
            if let ::std::option::Option::Some(spec::Spec::DifferentiatedSample(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::DifferentiatedSample(DifferentiatedSample::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::DifferentiatedSample(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_differentiated_sample(&mut self) -> DifferentiatedSample {
            if self.has_differentiated_sample() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::DifferentiatedSample(v)) => v,
                    _ => panic!(),
                }
            } else {
                DifferentiatedSample::new()
            }
        }

        // .Transform.ValidatedUserType validated_user_type = 31;

        pub fn validated_user_type(&self) -> &ValidatedUserType {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::ValidatedUserType(ref v)) => v,
                _ => <ValidatedUserType as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_validated_user_type(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_validated_user_type(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::ValidatedUserType(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_validated_user_type(&mut self, v: ValidatedUserType) {
            self.spec = ::std::option::Option::Some(spec::Spec::ValidatedUserType(v))
        }

        // Mutable pointer to the field.
        pub fn mut_validated_user_type(&mut self) -> &mut ValidatedUserType {
            if let ::std::option::Option::Some(spec::Spec::ValidatedUserType(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::ValidatedUserType(ValidatedUserType::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::ValidatedUserType(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_validated_user_type(&mut self) -> ValidatedUserType {
            if self.has_validated_user_type() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::ValidatedUserType(v)) => v,
                    _ => panic!(),
                }
            } else {
                ValidatedUserType::new()
            }
        }

        // .Transform.DPSelectSql dp_select_sql = 32;

        pub fn dp_select_sql(&self) -> &DPSelectSql {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::DpSelectSql(ref v)) => v,
                _ => <DPSelectSql as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_dp_select_sql(&mut self) {
            self.spec = ::std::option::Option::None;
        }

        pub fn has_dp_select_sql(&self) -> bool {
            match self.spec {
                ::std::option::Option::Some(spec::Spec::DpSelectSql(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_dp_select_sql(&mut self, v: DPSelectSql) {
            self.spec = ::std::option::Option::Some(spec::Spec::DpSelectSql(v))
        }

        // Mutable pointer to the field.
        pub fn mut_dp_select_sql(&mut self) -> &mut DPSelectSql {
            if let ::std::option::Option::Some(spec::Spec::DpSelectSql(_)) = self.spec {
            } else {
                self.spec = ::std::option::Option::Some(spec::Spec::DpSelectSql(DPSelectSql::new()));
            }
            match self.spec {
                ::std::option::Option::Some(spec::Spec::DpSelectSql(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_dp_select_sql(&mut self) -> DPSelectSql {
            if self.has_dp_select_sql() {
                match self.spec.take() {
                    ::std::option::Option::Some(spec::Spec::DpSelectSql(v)) => v,
                    _ => panic!(),
                }
            } else {
                DPSelectSql::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(32);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Identity>(
                "identity",
                Spec::has_identity,
                Spec::identity,
                Spec::mut_identity,
                Spec::set_identity,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Variable>(
                "variable",
                Spec::has_variable,
                Spec::variable,
                Spec::mut_variable,
                Spec::set_variable,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Composed>(
                "composed",
                Spec::has_composed,
                Spec::composed,
                Spec::mut_composed,
                Spec::set_composed,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Project>(
                "project",
                Spec::has_project,
                Spec::project,
                Spec::mut_project,
                Spec::set_project,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Filter>(
                "filter",
                Spec::has_filter,
                Spec::filter,
                Spec::mut_filter,
                Spec::set_filter,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Shuffle>(
                "shuffle",
                Spec::has_shuffle,
                Spec::shuffle,
                Spec::mut_shuffle,
                Spec::set_shuffle,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Join>(
                "join",
                Spec::has_join,
                Spec::join,
                Spec::mut_join,
                Spec::set_join,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Cast>(
                "cast",
                Spec::has_cast,
                Spec::cast,
                Spec::mut_cast,
                Spec::set_cast,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Sample>(
                "sample",
                Spec::has_sample,
                Spec::sample,
                Spec::mut_sample,
                Spec::set_sample,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, UserSettings>(
                "user_settings",
                Spec::has_user_settings,
                Spec::user_settings,
                Spec::mut_user_settings,
                Spec::set_user_settings,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Protect>(
                "protect_dataset",
                Spec::has_protect_dataset,
                Spec::protect_dataset,
                Spec::mut_protect_dataset,
                Spec::set_protect_dataset,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, External>(
                "external",
                Spec::has_external,
                Spec::external,
                Spec::mut_external,
                Spec::set_external,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Synthetic>(
                "synthetic",
                Spec::has_synthetic,
                Spec::synthetic,
                Spec::mut_synthetic,
                Spec::set_synthetic,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Transcode>(
                "transcode",
                Spec::has_transcode,
                Spec::transcode,
                Spec::mut_transcode,
                Spec::set_transcode,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, InverseTranscode>(
                "inverse_transcode",
                Spec::has_inverse_transcode,
                Spec::inverse_transcode,
                Spec::mut_inverse_transcode,
                Spec::set_inverse_transcode,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GetItem>(
                "get_item",
                Spec::has_get_item,
                Spec::get_item,
                Spec::mut_get_item,
                Spec::set_get_item,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ProtectedPaths>(
                "protected_paths",
                Spec::has_protected_paths,
                Spec::protected_paths,
                Spec::mut_protected_paths,
                Spec::set_protected_paths,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, AutomaticUserSettings>(
                "automatic_user_settings",
                Spec::has_automatic_user_settings,
                Spec::automatic_user_settings,
                Spec::mut_automatic_user_settings,
                Spec::set_automatic_user_settings,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PublicPaths>(
                "public_paths",
                Spec::has_public_paths,
                Spec::public_paths,
                Spec::mut_public_paths,
                Spec::set_public_paths,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, AssignBudget>(
                "assign_budget",
                Spec::has_assign_budget,
                Spec::assign_budget,
                Spec::mut_assign_budget,
                Spec::set_assign_budget,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, AutomaticBudget>(
                "automatic_budget",
                Spec::has_automatic_budget,
                Spec::automatic_budget,
                Spec::mut_automatic_budget,
                Spec::set_automatic_budget,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, AttributesBudget>(
                "attribute_budget",
                Spec::has_attribute_budget,
                Spec::attribute_budget,
                Spec::mut_attribute_budget,
                Spec::set_attribute_budget,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SDBudget>(
                "sd_budget",
                Spec::has_sd_budget,
                Spec::sd_budget,
                Spec::mut_sd_budget,
                Spec::set_sd_budget,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DeriveSeed>(
                "derive_seed",
                Spec::has_derive_seed,
                Spec::derive_seed,
                Spec::mut_derive_seed,
                Spec::set_derive_seed,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GroupByPE>(
                "group_by_pe",
                Spec::has_group_by_pe,
                Spec::group_by_pe,
                Spec::mut_group_by_pe,
                Spec::set_group_by_pe,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SamplingRatios>(
                "sampling_ratios",
                Spec::has_sampling_ratios,
                Spec::sampling_ratios,
                Spec::mut_sampling_ratios,
                Spec::set_sampling_ratios,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SelectSql>(
                "select_sql",
                Spec::has_select_sql,
                Spec::select_sql,
                Spec::mut_select_sql,
                Spec::set_select_sql,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Extract>(
                "extract",
                Spec::has_extract,
                Spec::extract,
                Spec::mut_extract,
                Spec::set_extract,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RelationshipSpec>(
                "relationship_spec",
                Spec::has_relationship_spec,
                Spec::relationship_spec,
                Spec::mut_relationship_spec,
                Spec::set_relationship_spec,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DifferentiatedSample>(
                "differentiated_sample",
                Spec::has_differentiated_sample,
                Spec::differentiated_sample,
                Spec::mut_differentiated_sample,
                Spec::set_differentiated_sample,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ValidatedUserType>(
                "validated_user_type",
                Spec::has_validated_user_type,
                Spec::validated_user_type,
                Spec::mut_validated_user_type,
                Spec::set_validated_user_type,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DPSelectSql>(
                "dp_select_sql",
                Spec::has_dp_select_sql,
                Spec::dp_select_sql,
                Spec::mut_dp_select_sql,
                Spec::set_dp_select_sql,
            ));
            oneofs.push(spec::Spec::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Spec>(
                "Transform.Spec",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Spec {
        const NAME: &'static str = "Spec";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::Identity(is.read_message()?));
                    },
                    18 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::Variable(is.read_message()?));
                    },
                    26 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::Composed(is.read_message()?));
                    },
                    34 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::Project(is.read_message()?));
                    },
                    42 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::Filter(is.read_message()?));
                    },
                    50 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::Shuffle(is.read_message()?));
                    },
                    58 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::Join(is.read_message()?));
                    },
                    66 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::Cast(is.read_message()?));
                    },
                    74 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::Sample(is.read_message()?));
                    },
                    82 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::UserSettings(is.read_message()?));
                    },
                    90 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::ProtectDataset(is.read_message()?));
                    },
                    98 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::External(is.read_message()?));
                    },
                    106 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::Synthetic(is.read_message()?));
                    },
                    114 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::Transcode(is.read_message()?));
                    },
                    122 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::InverseTranscode(is.read_message()?));
                    },
                    130 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::GetItem(is.read_message()?));
                    },
                    138 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::ProtectedPaths(is.read_message()?));
                    },
                    146 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::AutomaticUserSettings(is.read_message()?));
                    },
                    154 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::PublicPaths(is.read_message()?));
                    },
                    162 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::AssignBudget(is.read_message()?));
                    },
                    170 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::AutomaticBudget(is.read_message()?));
                    },
                    178 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::AttributeBudget(is.read_message()?));
                    },
                    186 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::SdBudget(is.read_message()?));
                    },
                    194 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::DeriveSeed(is.read_message()?));
                    },
                    202 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::GroupByPe(is.read_message()?));
                    },
                    210 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::SamplingRatios(is.read_message()?));
                    },
                    218 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::SelectSql(is.read_message()?));
                    },
                    226 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::Extract(is.read_message()?));
                    },
                    234 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::RelationshipSpec(is.read_message()?));
                    },
                    242 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::DifferentiatedSample(is.read_message()?));
                    },
                    250 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::ValidatedUserType(is.read_message()?));
                    },
                    258 => {
                        self.spec = ::std::option::Option::Some(spec::Spec::DpSelectSql(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.spec {
                match v {
                    &spec::Spec::Identity(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::Variable(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::Composed(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::Project(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::Filter(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::Shuffle(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::Join(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::Cast(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::Sample(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::UserSettings(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::ProtectDataset(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::External(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::Synthetic(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::Transcode(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::InverseTranscode(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::GetItem(ref v) => {
                        let len = v.compute_size();
                        my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::ProtectedPaths(ref v) => {
                        let len = v.compute_size();
                        my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::AutomaticUserSettings(ref v) => {
                        let len = v.compute_size();
                        my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::PublicPaths(ref v) => {
                        let len = v.compute_size();
                        my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::AssignBudget(ref v) => {
                        let len = v.compute_size();
                        my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::AutomaticBudget(ref v) => {
                        let len = v.compute_size();
                        my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::AttributeBudget(ref v) => {
                        let len = v.compute_size();
                        my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::SdBudget(ref v) => {
                        let len = v.compute_size();
                        my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::DeriveSeed(ref v) => {
                        let len = v.compute_size();
                        my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::GroupByPe(ref v) => {
                        let len = v.compute_size();
                        my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::SamplingRatios(ref v) => {
                        let len = v.compute_size();
                        my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::SelectSql(ref v) => {
                        let len = v.compute_size();
                        my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::Extract(ref v) => {
                        let len = v.compute_size();
                        my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::RelationshipSpec(ref v) => {
                        let len = v.compute_size();
                        my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::DifferentiatedSample(ref v) => {
                        let len = v.compute_size();
                        my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::ValidatedUserType(ref v) => {
                        let len = v.compute_size();
                        my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &spec::Spec::DpSelectSql(ref v) => {
                        let len = v.compute_size();
                        my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.spec {
                match v {
                    &spec::Spec::Identity(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    },
                    &spec::Spec::Variable(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                    &spec::Spec::Composed(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                    },
                    &spec::Spec::Project(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                    },
                    &spec::Spec::Filter(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                    },
                    &spec::Spec::Shuffle(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                    },
                    &spec::Spec::Join(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                    },
                    &spec::Spec::Cast(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                    },
                    &spec::Spec::Sample(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                    },
                    &spec::Spec::UserSettings(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                    },
                    &spec::Spec::ProtectDataset(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                    },
                    &spec::Spec::External(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                    },
                    &spec::Spec::Synthetic(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                    },
                    &spec::Spec::Transcode(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                    },
                    &spec::Spec::InverseTranscode(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                    },
                    &spec::Spec::GetItem(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
                    },
                    &spec::Spec::ProtectedPaths(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
                    },
                    &spec::Spec::AutomaticUserSettings(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
                    },
                    &spec::Spec::PublicPaths(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
                    },
                    &spec::Spec::AssignBudget(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
                    },
                    &spec::Spec::AutomaticBudget(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
                    },
                    &spec::Spec::AttributeBudget(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
                    },
                    &spec::Spec::SdBudget(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
                    },
                    &spec::Spec::DeriveSeed(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
                    },
                    &spec::Spec::GroupByPe(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
                    },
                    &spec::Spec::SamplingRatios(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
                    },
                    &spec::Spec::SelectSql(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
                    },
                    &spec::Spec::Extract(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
                    },
                    &spec::Spec::RelationshipSpec(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(29, v, os)?;
                    },
                    &spec::Spec::DifferentiatedSample(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
                    },
                    &spec::Spec::ValidatedUserType(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
                    },
                    &spec::Spec::DpSelectSql(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Spec {
            Spec::new()
        }

        fn clear(&mut self) {
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.spec = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Spec {
            static instance: Spec = Spec {
                spec: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Spec {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.Spec").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Spec {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Spec {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Spec`
    pub mod spec {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:Transform.Spec.spec)
        pub enum Spec {
            // @@protoc_insertion_point(oneof_field:Transform.Spec.identity)
            Identity(super::Identity),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.variable)
            Variable(super::Variable),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.composed)
            Composed(super::Composed),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.project)
            Project(super::Project),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.filter)
            Filter(super::Filter),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.shuffle)
            Shuffle(super::Shuffle),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.join)
            Join(super::Join),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.cast)
            Cast(super::Cast),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.sample)
            Sample(super::Sample),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.user_settings)
            UserSettings(super::UserSettings),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.protect_dataset)
            ProtectDataset(super::Protect),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.external)
            External(super::External),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.synthetic)
            Synthetic(super::Synthetic),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.transcode)
            Transcode(super::Transcode),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.inverse_transcode)
            InverseTranscode(super::InverseTranscode),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.get_item)
            GetItem(super::GetItem),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.protected_paths)
            ProtectedPaths(super::ProtectedPaths),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.automatic_user_settings)
            AutomaticUserSettings(super::AutomaticUserSettings),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.public_paths)
            PublicPaths(super::PublicPaths),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.assign_budget)
            AssignBudget(super::AssignBudget),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.automatic_budget)
            AutomaticBudget(super::AutomaticBudget),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.attribute_budget)
            AttributeBudget(super::AttributesBudget),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.sd_budget)
            SdBudget(super::SDBudget),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.derive_seed)
            DeriveSeed(super::DeriveSeed),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.group_by_pe)
            GroupByPe(super::GroupByPE),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.sampling_ratios)
            SamplingRatios(super::SamplingRatios),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.select_sql)
            SelectSql(super::SelectSql),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.extract)
            Extract(super::Extract),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.relationship_spec)
            RelationshipSpec(super::RelationshipSpec),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.differentiated_sample)
            DifferentiatedSample(super::DifferentiatedSample),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.validated_user_type)
            ValidatedUserType(super::ValidatedUserType),
            // @@protoc_insertion_point(oneof_field:Transform.Spec.dp_select_sql)
            DpSelectSql(super::DPSelectSql),
        }

        impl ::protobuf::Oneof for Spec {
        }

        impl ::protobuf::OneofFull for Spec {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::Spec as ::protobuf::MessageFull>::descriptor().oneof_by_name("spec").unwrap()).clone()
            }
        }

        impl Spec {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Spec>("spec")
            }
        }
    }

    // @@protoc_insertion_point(message:Transform.External)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct External {
        // message fields
        // @@protoc_insertion_point(field:Transform.External.arguments)
        pub arguments: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:Transform.External.named_arguments)
        pub named_arguments: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:Transform.External.op_identifier)
        pub op_identifier: ::protobuf::MessageField<external::OpIdentifier>,
        // special fields
        // @@protoc_insertion_point(special_field:Transform.External.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a External {
        fn default() -> &'a External {
            <External as ::protobuf::Message>::default_instance()
        }
    }

    impl External {
        pub fn new() -> External {
            ::std::default::Default::default()
        }

        // bytes arguments = 1;

        pub fn arguments(&self) -> &[u8] {
            &self.arguments
        }

        pub fn clear_arguments(&mut self) {
            self.arguments.clear();
        }

        // Param is passed by value, moved
        pub fn set_arguments(&mut self, v: ::std::vec::Vec<u8>) {
            self.arguments = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_arguments(&mut self) -> &mut ::std::vec::Vec<u8> {
            &mut self.arguments
        }

        // Take field
        pub fn take_arguments(&mut self) -> ::std::vec::Vec<u8> {
            ::std::mem::replace(&mut self.arguments, ::std::vec::Vec::new())
        }

        // bytes named_arguments = 2;

        pub fn named_arguments(&self) -> &[u8] {
            &self.named_arguments
        }

        pub fn clear_named_arguments(&mut self) {
            self.named_arguments.clear();
        }

        // Param is passed by value, moved
        pub fn set_named_arguments(&mut self, v: ::std::vec::Vec<u8>) {
            self.named_arguments = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_named_arguments(&mut self) -> &mut ::std::vec::Vec<u8> {
            &mut self.named_arguments
        }

        // Take field
        pub fn take_named_arguments(&mut self) -> ::std::vec::Vec<u8> {
            ::std::mem::replace(&mut self.named_arguments, ::std::vec::Vec::new())
        }

        // .Transform.External.OpIdentifier op_identifier = 3;

        pub fn op_identifier(&self) -> &external::OpIdentifier {
            self.op_identifier.as_ref().unwrap_or_else(|| <external::OpIdentifier as ::protobuf::Message>::default_instance())
        }

        pub fn clear_op_identifier(&mut self) {
            self.op_identifier.clear();
        }

        pub fn has_op_identifier(&self) -> bool {
            self.op_identifier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_op_identifier(&mut self, v: external::OpIdentifier) {
            self.op_identifier = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_op_identifier(&mut self) -> &mut external::OpIdentifier {
            self.op_identifier.mut_or_insert_default()
        }

        // Take field
        pub fn take_op_identifier(&mut self) -> external::OpIdentifier {
            self.op_identifier.take().unwrap_or_else(|| external::OpIdentifier::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "arguments",
                |m: &External| { &m.arguments },
                |m: &mut External| { &mut m.arguments },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "named_arguments",
                |m: &External| { &m.named_arguments },
                |m: &mut External| { &mut m.named_arguments },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, external::OpIdentifier>(
                "op_identifier",
                |m: &External| { &m.op_identifier },
                |m: &mut External| { &mut m.op_identifier },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<External>(
                "Transform.External",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for External {
        const NAME: &'static str = "External";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.arguments = is.read_bytes()?;
                    },
                    18 => {
                        self.named_arguments = is.read_bytes()?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.op_identifier)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.arguments.is_empty() {
                my_size += ::protobuf::rt::bytes_size(1, &self.arguments);
            }
            if !self.named_arguments.is_empty() {
                my_size += ::protobuf::rt::bytes_size(2, &self.named_arguments);
            }
            if let Some(v) = self.op_identifier.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.arguments.is_empty() {
                os.write_bytes(1, &self.arguments)?;
            }
            if !self.named_arguments.is_empty() {
                os.write_bytes(2, &self.named_arguments)?;
            }
            if let Some(v) = self.op_identifier.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> External {
            External::new()
        }

        fn clear(&mut self) {
            self.arguments.clear();
            self.named_arguments.clear();
            self.op_identifier.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static External {
            static instance: External = External {
                arguments: ::std::vec::Vec::new(),
                named_arguments: ::std::vec::Vec::new(),
                op_identifier: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for External {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.External").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for External {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for External {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `External`
    pub mod external {
        // @@protoc_insertion_point(message:Transform.External.OpIdentifier)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct OpIdentifier {
            // message oneof groups
            pub op: ::std::option::Option<op_identifier::Op>,
            // special fields
            // @@protoc_insertion_point(special_field:Transform.External.OpIdentifier.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a OpIdentifier {
            fn default() -> &'a OpIdentifier {
                <OpIdentifier as ::protobuf::Message>::default_instance()
            }
        }

        impl OpIdentifier {
            pub fn new() -> OpIdentifier {
                ::std::default::Default::default()
            }

            // .Transform.External.Std std = 1;

            pub fn std(&self) -> &Std {
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::Std(ref v)) => v,
                    _ => <Std as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_std(&mut self) {
                self.op = ::std::option::Option::None;
            }

            pub fn has_std(&self) -> bool {
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::Std(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_std(&mut self, v: Std) {
                self.op = ::std::option::Option::Some(op_identifier::Op::Std(v))
            }

            // Mutable pointer to the field.
            pub fn mut_std(&mut self) -> &mut Std {
                if let ::std::option::Option::Some(op_identifier::Op::Std(_)) = self.op {
                } else {
                    self.op = ::std::option::Option::Some(op_identifier::Op::Std(Std::new()));
                }
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::Std(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_std(&mut self) -> Std {
                if self.has_std() {
                    match self.op.take() {
                        ::std::option::Option::Some(op_identifier::Op::Std(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    Std::new()
                }
            }

            // .Transform.External.Pandas pandas = 2;

            pub fn pandas(&self) -> &Pandas {
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::Pandas(ref v)) => v,
                    _ => <Pandas as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_pandas(&mut self) {
                self.op = ::std::option::Option::None;
            }

            pub fn has_pandas(&self) -> bool {
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::Pandas(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_pandas(&mut self, v: Pandas) {
                self.op = ::std::option::Option::Some(op_identifier::Op::Pandas(v))
            }

            // Mutable pointer to the field.
            pub fn mut_pandas(&mut self) -> &mut Pandas {
                if let ::std::option::Option::Some(op_identifier::Op::Pandas(_)) = self.op {
                } else {
                    self.op = ::std::option::Option::Some(op_identifier::Op::Pandas(Pandas::new()));
                }
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::Pandas(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_pandas(&mut self) -> Pandas {
                if self.has_pandas() {
                    match self.op.take() {
                        ::std::option::Option::Some(op_identifier::Op::Pandas(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    Pandas::new()
                }
            }

            // .Transform.External.Numpy numpy = 3;

            pub fn numpy(&self) -> &Numpy {
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::Numpy(ref v)) => v,
                    _ => <Numpy as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_numpy(&mut self) {
                self.op = ::std::option::Option::None;
            }

            pub fn has_numpy(&self) -> bool {
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::Numpy(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_numpy(&mut self, v: Numpy) {
                self.op = ::std::option::Option::Some(op_identifier::Op::Numpy(v))
            }

            // Mutable pointer to the field.
            pub fn mut_numpy(&mut self) -> &mut Numpy {
                if let ::std::option::Option::Some(op_identifier::Op::Numpy(_)) = self.op {
                } else {
                    self.op = ::std::option::Option::Some(op_identifier::Op::Numpy(Numpy::new()));
                }
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::Numpy(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_numpy(&mut self) -> Numpy {
                if self.has_numpy() {
                    match self.op.take() {
                        ::std::option::Option::Some(op_identifier::Op::Numpy(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    Numpy::new()
                }
            }

            // .Transform.External.Tensorflow tensorflow = 4;

            pub fn tensorflow(&self) -> &Tensorflow {
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::Tensorflow(ref v)) => v,
                    _ => <Tensorflow as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_tensorflow(&mut self) {
                self.op = ::std::option::Option::None;
            }

            pub fn has_tensorflow(&self) -> bool {
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::Tensorflow(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_tensorflow(&mut self, v: Tensorflow) {
                self.op = ::std::option::Option::Some(op_identifier::Op::Tensorflow(v))
            }

            // Mutable pointer to the field.
            pub fn mut_tensorflow(&mut self) -> &mut Tensorflow {
                if let ::std::option::Option::Some(op_identifier::Op::Tensorflow(_)) = self.op {
                } else {
                    self.op = ::std::option::Option::Some(op_identifier::Op::Tensorflow(Tensorflow::new()));
                }
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::Tensorflow(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_tensorflow(&mut self) -> Tensorflow {
                if self.has_tensorflow() {
                    match self.op.take() {
                        ::std::option::Option::Some(op_identifier::Op::Tensorflow(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    Tensorflow::new()
                }
            }

            // .Transform.External.Sklearn sklearn = 5;

            pub fn sklearn(&self) -> &Sklearn {
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::Sklearn(ref v)) => v,
                    _ => <Sklearn as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_sklearn(&mut self) {
                self.op = ::std::option::Option::None;
            }

            pub fn has_sklearn(&self) -> bool {
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::Sklearn(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_sklearn(&mut self, v: Sklearn) {
                self.op = ::std::option::Option::Some(op_identifier::Op::Sklearn(v))
            }

            // Mutable pointer to the field.
            pub fn mut_sklearn(&mut self) -> &mut Sklearn {
                if let ::std::option::Option::Some(op_identifier::Op::Sklearn(_)) = self.op {
                } else {
                    self.op = ::std::option::Option::Some(op_identifier::Op::Sklearn(Sklearn::new()));
                }
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::Sklearn(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_sklearn(&mut self) -> Sklearn {
                if self.has_sklearn() {
                    match self.op.take() {
                        ::std::option::Option::Some(op_identifier::Op::Sklearn(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    Sklearn::new()
                }
            }

            // .Transform.External.PandasProfiling pandas_profiling = 6;

            pub fn pandas_profiling(&self) -> &PandasProfiling {
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::PandasProfiling(ref v)) => v,
                    _ => <PandasProfiling as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_pandas_profiling(&mut self) {
                self.op = ::std::option::Option::None;
            }

            pub fn has_pandas_profiling(&self) -> bool {
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::PandasProfiling(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_pandas_profiling(&mut self, v: PandasProfiling) {
                self.op = ::std::option::Option::Some(op_identifier::Op::PandasProfiling(v))
            }

            // Mutable pointer to the field.
            pub fn mut_pandas_profiling(&mut self) -> &mut PandasProfiling {
                if let ::std::option::Option::Some(op_identifier::Op::PandasProfiling(_)) = self.op {
                } else {
                    self.op = ::std::option::Option::Some(op_identifier::Op::PandasProfiling(PandasProfiling::new()));
                }
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::PandasProfiling(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_pandas_profiling(&mut self) -> PandasProfiling {
                if self.has_pandas_profiling() {
                    match self.op.take() {
                        ::std::option::Option::Some(op_identifier::Op::PandasProfiling(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    PandasProfiling::new()
                }
            }

            // .Transform.External.XGBoost xgboost = 7;

            pub fn xgboost(&self) -> &XGBoost {
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::Xgboost(ref v)) => v,
                    _ => <XGBoost as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_xgboost(&mut self) {
                self.op = ::std::option::Option::None;
            }

            pub fn has_xgboost(&self) -> bool {
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::Xgboost(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_xgboost(&mut self, v: XGBoost) {
                self.op = ::std::option::Option::Some(op_identifier::Op::Xgboost(v))
            }

            // Mutable pointer to the field.
            pub fn mut_xgboost(&mut self) -> &mut XGBoost {
                if let ::std::option::Option::Some(op_identifier::Op::Xgboost(_)) = self.op {
                } else {
                    self.op = ::std::option::Option::Some(op_identifier::Op::Xgboost(XGBoost::new()));
                }
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::Xgboost(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_xgboost(&mut self) -> XGBoost {
                if self.has_xgboost() {
                    match self.op.take() {
                        ::std::option::Option::Some(op_identifier::Op::Xgboost(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    XGBoost::new()
                }
            }

            // .Transform.External.Skopt skopt = 8;

            pub fn skopt(&self) -> &Skopt {
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::Skopt(ref v)) => v,
                    _ => <Skopt as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_skopt(&mut self) {
                self.op = ::std::option::Option::None;
            }

            pub fn has_skopt(&self) -> bool {
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::Skopt(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_skopt(&mut self, v: Skopt) {
                self.op = ::std::option::Option::Some(op_identifier::Op::Skopt(v))
            }

            // Mutable pointer to the field.
            pub fn mut_skopt(&mut self) -> &mut Skopt {
                if let ::std::option::Option::Some(op_identifier::Op::Skopt(_)) = self.op {
                } else {
                    self.op = ::std::option::Option::Some(op_identifier::Op::Skopt(Skopt::new()));
                }
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::Skopt(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_skopt(&mut self) -> Skopt {
                if self.has_skopt() {
                    match self.op.take() {
                        ::std::option::Option::Some(op_identifier::Op::Skopt(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    Skopt::new()
                }
            }

            // .Transform.External.Imblearn imblearn = 9;

            pub fn imblearn(&self) -> &Imblearn {
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::Imblearn(ref v)) => v,
                    _ => <Imblearn as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_imblearn(&mut self) {
                self.op = ::std::option::Option::None;
            }

            pub fn has_imblearn(&self) -> bool {
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::Imblearn(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_imblearn(&mut self, v: Imblearn) {
                self.op = ::std::option::Option::Some(op_identifier::Op::Imblearn(v))
            }

            // Mutable pointer to the field.
            pub fn mut_imblearn(&mut self) -> &mut Imblearn {
                if let ::std::option::Option::Some(op_identifier::Op::Imblearn(_)) = self.op {
                } else {
                    self.op = ::std::option::Option::Some(op_identifier::Op::Imblearn(Imblearn::new()));
                }
                match self.op {
                    ::std::option::Option::Some(op_identifier::Op::Imblearn(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_imblearn(&mut self) -> Imblearn {
                if self.has_imblearn() {
                    match self.op.take() {
                        ::std::option::Option::Some(op_identifier::Op::Imblearn(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    Imblearn::new()
                }
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(9);
                let mut oneofs = ::std::vec::Vec::with_capacity(1);
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Std>(
                    "std",
                    OpIdentifier::has_std,
                    OpIdentifier::std,
                    OpIdentifier::mut_std,
                    OpIdentifier::set_std,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Pandas>(
                    "pandas",
                    OpIdentifier::has_pandas,
                    OpIdentifier::pandas,
                    OpIdentifier::mut_pandas,
                    OpIdentifier::set_pandas,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Numpy>(
                    "numpy",
                    OpIdentifier::has_numpy,
                    OpIdentifier::numpy,
                    OpIdentifier::mut_numpy,
                    OpIdentifier::set_numpy,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Tensorflow>(
                    "tensorflow",
                    OpIdentifier::has_tensorflow,
                    OpIdentifier::tensorflow,
                    OpIdentifier::mut_tensorflow,
                    OpIdentifier::set_tensorflow,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Sklearn>(
                    "sklearn",
                    OpIdentifier::has_sklearn,
                    OpIdentifier::sklearn,
                    OpIdentifier::mut_sklearn,
                    OpIdentifier::set_sklearn,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PandasProfiling>(
                    "pandas_profiling",
                    OpIdentifier::has_pandas_profiling,
                    OpIdentifier::pandas_profiling,
                    OpIdentifier::mut_pandas_profiling,
                    OpIdentifier::set_pandas_profiling,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, XGBoost>(
                    "xgboost",
                    OpIdentifier::has_xgboost,
                    OpIdentifier::xgboost,
                    OpIdentifier::mut_xgboost,
                    OpIdentifier::set_xgboost,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Skopt>(
                    "skopt",
                    OpIdentifier::has_skopt,
                    OpIdentifier::skopt,
                    OpIdentifier::mut_skopt,
                    OpIdentifier::set_skopt,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Imblearn>(
                    "imblearn",
                    OpIdentifier::has_imblearn,
                    OpIdentifier::imblearn,
                    OpIdentifier::mut_imblearn,
                    OpIdentifier::set_imblearn,
                ));
                oneofs.push(op_identifier::Op::generated_oneof_descriptor_data());
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OpIdentifier>(
                    "Transform.External.OpIdentifier",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for OpIdentifier {
            const NAME: &'static str = "OpIdentifier";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.op = ::std::option::Option::Some(op_identifier::Op::Std(is.read_message()?));
                        },
                        18 => {
                            self.op = ::std::option::Option::Some(op_identifier::Op::Pandas(is.read_message()?));
                        },
                        26 => {
                            self.op = ::std::option::Option::Some(op_identifier::Op::Numpy(is.read_message()?));
                        },
                        34 => {
                            self.op = ::std::option::Option::Some(op_identifier::Op::Tensorflow(is.read_message()?));
                        },
                        42 => {
                            self.op = ::std::option::Option::Some(op_identifier::Op::Sklearn(is.read_message()?));
                        },
                        50 => {
                            self.op = ::std::option::Option::Some(op_identifier::Op::PandasProfiling(is.read_message()?));
                        },
                        58 => {
                            self.op = ::std::option::Option::Some(op_identifier::Op::Xgboost(is.read_message()?));
                        },
                        66 => {
                            self.op = ::std::option::Option::Some(op_identifier::Op::Skopt(is.read_message()?));
                        },
                        74 => {
                            self.op = ::std::option::Option::Some(op_identifier::Op::Imblearn(is.read_message()?));
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let ::std::option::Option::Some(ref v) = self.op {
                    match v {
                        &op_identifier::Op::Std(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                        &op_identifier::Op::Pandas(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                        &op_identifier::Op::Numpy(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                        &op_identifier::Op::Tensorflow(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                        &op_identifier::Op::Sklearn(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                        &op_identifier::Op::PandasProfiling(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                        &op_identifier::Op::Xgboost(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                        &op_identifier::Op::Skopt(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                        &op_identifier::Op::Imblearn(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                    };
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let ::std::option::Option::Some(ref v) = self.op {
                    match v {
                        &op_identifier::Op::Std(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                        },
                        &op_identifier::Op::Pandas(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                        },
                        &op_identifier::Op::Numpy(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                        },
                        &op_identifier::Op::Tensorflow(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                        },
                        &op_identifier::Op::Sklearn(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                        },
                        &op_identifier::Op::PandasProfiling(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                        },
                        &op_identifier::Op::Xgboost(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                        },
                        &op_identifier::Op::Skopt(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                        },
                        &op_identifier::Op::Imblearn(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                        },
                    };
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> OpIdentifier {
                OpIdentifier::new()
            }

            fn clear(&mut self) {
                self.op = ::std::option::Option::None;
                self.op = ::std::option::Option::None;
                self.op = ::std::option::Option::None;
                self.op = ::std::option::Option::None;
                self.op = ::std::option::Option::None;
                self.op = ::std::option::Option::None;
                self.op = ::std::option::Option::None;
                self.op = ::std::option::Option::None;
                self.op = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static OpIdentifier {
                static instance: OpIdentifier = OpIdentifier {
                    op: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for OpIdentifier {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Transform.External.OpIdentifier").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for OpIdentifier {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for OpIdentifier {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `OpIdentifier`
        pub mod op_identifier {

            #[derive(Clone,PartialEq,Debug)]
            #[non_exhaustive]
            // @@protoc_insertion_point(oneof:Transform.External.OpIdentifier.op)
            pub enum Op {
                // @@protoc_insertion_point(oneof_field:Transform.External.OpIdentifier.std)
                Std(super::Std),
                // @@protoc_insertion_point(oneof_field:Transform.External.OpIdentifier.pandas)
                Pandas(super::Pandas),
                // @@protoc_insertion_point(oneof_field:Transform.External.OpIdentifier.numpy)
                Numpy(super::Numpy),
                // @@protoc_insertion_point(oneof_field:Transform.External.OpIdentifier.tensorflow)
                Tensorflow(super::Tensorflow),
                // @@protoc_insertion_point(oneof_field:Transform.External.OpIdentifier.sklearn)
                Sklearn(super::Sklearn),
                // @@protoc_insertion_point(oneof_field:Transform.External.OpIdentifier.pandas_profiling)
                PandasProfiling(super::PandasProfiling),
                // @@protoc_insertion_point(oneof_field:Transform.External.OpIdentifier.xgboost)
                Xgboost(super::XGBoost),
                // @@protoc_insertion_point(oneof_field:Transform.External.OpIdentifier.skopt)
                Skopt(super::Skopt),
                // @@protoc_insertion_point(oneof_field:Transform.External.OpIdentifier.imblearn)
                Imblearn(super::Imblearn),
            }

            impl ::protobuf::Oneof for Op {
            }

            impl ::protobuf::OneofFull for Op {
                fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| <super::OpIdentifier as ::protobuf::MessageFull>::descriptor().oneof_by_name("op").unwrap()).clone()
                }
            }

            impl Op {
                pub(in super::super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                    ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Op>("op")
                }
            }
        }

        // @@protoc_insertion_point(message:Transform.External.Std)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Std {
            // message fields
            // @@protoc_insertion_point(field:Transform.External.Std.name)
            pub name: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:Transform.External.Std.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Std {
            fn default() -> &'a Std {
                <Std as ::protobuf::Message>::default_instance()
            }
        }

        impl Std {
            pub fn new() -> Std {
                ::std::default::Default::default()
            }

            // string name = 1;

            pub fn name(&self) -> &str {
                &self.name
            }

            pub fn clear_name(&mut self) {
                self.name.clear();
            }

            // Param is passed by value, moved
            pub fn set_name(&mut self, v: ::std::string::String) {
                self.name = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_name(&mut self) -> &mut ::std::string::String {
                &mut self.name
            }

            // Take field
            pub fn take_name(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.name, ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "name",
                    |m: &Std| { &m.name },
                    |m: &mut Std| { &mut m.name },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Std>(
                    "Transform.External.Std",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Std {
            const NAME: &'static str = "Std";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.name = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.name.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.name);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.name.is_empty() {
                    os.write_string(1, &self.name)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Std {
                Std::new()
            }

            fn clear(&mut self) {
                self.name.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Std {
                static instance: Std = Std {
                    name: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Std {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Transform.External.Std").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Std {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Std {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:Transform.External.Pandas)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Pandas {
            // message fields
            // @@protoc_insertion_point(field:Transform.External.Pandas.name)
            pub name: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:Transform.External.Pandas.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Pandas {
            fn default() -> &'a Pandas {
                <Pandas as ::protobuf::Message>::default_instance()
            }
        }

        impl Pandas {
            pub fn new() -> Pandas {
                ::std::default::Default::default()
            }

            // string name = 1;

            pub fn name(&self) -> &str {
                &self.name
            }

            pub fn clear_name(&mut self) {
                self.name.clear();
            }

            // Param is passed by value, moved
            pub fn set_name(&mut self, v: ::std::string::String) {
                self.name = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_name(&mut self) -> &mut ::std::string::String {
                &mut self.name
            }

            // Take field
            pub fn take_name(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.name, ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "name",
                    |m: &Pandas| { &m.name },
                    |m: &mut Pandas| { &mut m.name },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pandas>(
                    "Transform.External.Pandas",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Pandas {
            const NAME: &'static str = "Pandas";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.name = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.name.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.name);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.name.is_empty() {
                    os.write_string(1, &self.name)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Pandas {
                Pandas::new()
            }

            fn clear(&mut self) {
                self.name.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Pandas {
                static instance: Pandas = Pandas {
                    name: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Pandas {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Transform.External.Pandas").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Pandas {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Pandas {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:Transform.External.Numpy)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Numpy {
            // message fields
            // @@protoc_insertion_point(field:Transform.External.Numpy.name)
            pub name: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:Transform.External.Numpy.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Numpy {
            fn default() -> &'a Numpy {
                <Numpy as ::protobuf::Message>::default_instance()
            }
        }

        impl Numpy {
            pub fn new() -> Numpy {
                ::std::default::Default::default()
            }

            // string name = 1;

            pub fn name(&self) -> &str {
                &self.name
            }

            pub fn clear_name(&mut self) {
                self.name.clear();
            }

            // Param is passed by value, moved
            pub fn set_name(&mut self, v: ::std::string::String) {
                self.name = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_name(&mut self) -> &mut ::std::string::String {
                &mut self.name
            }

            // Take field
            pub fn take_name(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.name, ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "name",
                    |m: &Numpy| { &m.name },
                    |m: &mut Numpy| { &mut m.name },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Numpy>(
                    "Transform.External.Numpy",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Numpy {
            const NAME: &'static str = "Numpy";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.name = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.name.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.name);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.name.is_empty() {
                    os.write_string(1, &self.name)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Numpy {
                Numpy::new()
            }

            fn clear(&mut self) {
                self.name.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Numpy {
                static instance: Numpy = Numpy {
                    name: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Numpy {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Transform.External.Numpy").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Numpy {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Numpy {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:Transform.External.Tensorflow)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Tensorflow {
            // message fields
            // @@protoc_insertion_point(field:Transform.External.Tensorflow.name)
            pub name: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:Transform.External.Tensorflow.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Tensorflow {
            fn default() -> &'a Tensorflow {
                <Tensorflow as ::protobuf::Message>::default_instance()
            }
        }

        impl Tensorflow {
            pub fn new() -> Tensorflow {
                ::std::default::Default::default()
            }

            // string name = 1;

            pub fn name(&self) -> &str {
                &self.name
            }

            pub fn clear_name(&mut self) {
                self.name.clear();
            }

            // Param is passed by value, moved
            pub fn set_name(&mut self, v: ::std::string::String) {
                self.name = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_name(&mut self) -> &mut ::std::string::String {
                &mut self.name
            }

            // Take field
            pub fn take_name(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.name, ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "name",
                    |m: &Tensorflow| { &m.name },
                    |m: &mut Tensorflow| { &mut m.name },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Tensorflow>(
                    "Transform.External.Tensorflow",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Tensorflow {
            const NAME: &'static str = "Tensorflow";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.name = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.name.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.name);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.name.is_empty() {
                    os.write_string(1, &self.name)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Tensorflow {
                Tensorflow::new()
            }

            fn clear(&mut self) {
                self.name.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Tensorflow {
                static instance: Tensorflow = Tensorflow {
                    name: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Tensorflow {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Transform.External.Tensorflow").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Tensorflow {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Tensorflow {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:Transform.External.Sklearn)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Sklearn {
            // message fields
            // @@protoc_insertion_point(field:Transform.External.Sklearn.name)
            pub name: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:Transform.External.Sklearn.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Sklearn {
            fn default() -> &'a Sklearn {
                <Sklearn as ::protobuf::Message>::default_instance()
            }
        }

        impl Sklearn {
            pub fn new() -> Sklearn {
                ::std::default::Default::default()
            }

            // string name = 1;

            pub fn name(&self) -> &str {
                &self.name
            }

            pub fn clear_name(&mut self) {
                self.name.clear();
            }

            // Param is passed by value, moved
            pub fn set_name(&mut self, v: ::std::string::String) {
                self.name = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_name(&mut self) -> &mut ::std::string::String {
                &mut self.name
            }

            // Take field
            pub fn take_name(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.name, ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "name",
                    |m: &Sklearn| { &m.name },
                    |m: &mut Sklearn| { &mut m.name },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Sklearn>(
                    "Transform.External.Sklearn",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Sklearn {
            const NAME: &'static str = "Sklearn";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.name = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.name.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.name);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.name.is_empty() {
                    os.write_string(1, &self.name)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Sklearn {
                Sklearn::new()
            }

            fn clear(&mut self) {
                self.name.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Sklearn {
                static instance: Sklearn = Sklearn {
                    name: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Sklearn {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Transform.External.Sklearn").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Sklearn {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Sklearn {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:Transform.External.PandasProfiling)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct PandasProfiling {
            // message fields
            // @@protoc_insertion_point(field:Transform.External.PandasProfiling.name)
            pub name: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:Transform.External.PandasProfiling.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a PandasProfiling {
            fn default() -> &'a PandasProfiling {
                <PandasProfiling as ::protobuf::Message>::default_instance()
            }
        }

        impl PandasProfiling {
            pub fn new() -> PandasProfiling {
                ::std::default::Default::default()
            }

            // string name = 1;

            pub fn name(&self) -> &str {
                &self.name
            }

            pub fn clear_name(&mut self) {
                self.name.clear();
            }

            // Param is passed by value, moved
            pub fn set_name(&mut self, v: ::std::string::String) {
                self.name = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_name(&mut self) -> &mut ::std::string::String {
                &mut self.name
            }

            // Take field
            pub fn take_name(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.name, ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "name",
                    |m: &PandasProfiling| { &m.name },
                    |m: &mut PandasProfiling| { &mut m.name },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PandasProfiling>(
                    "Transform.External.PandasProfiling",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for PandasProfiling {
            const NAME: &'static str = "PandasProfiling";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.name = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.name.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.name);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.name.is_empty() {
                    os.write_string(1, &self.name)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> PandasProfiling {
                PandasProfiling::new()
            }

            fn clear(&mut self) {
                self.name.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static PandasProfiling {
                static instance: PandasProfiling = PandasProfiling {
                    name: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for PandasProfiling {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Transform.External.PandasProfiling").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for PandasProfiling {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for PandasProfiling {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:Transform.External.XGBoost)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct XGBoost {
            // message fields
            // @@protoc_insertion_point(field:Transform.External.XGBoost.name)
            pub name: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:Transform.External.XGBoost.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a XGBoost {
            fn default() -> &'a XGBoost {
                <XGBoost as ::protobuf::Message>::default_instance()
            }
        }

        impl XGBoost {
            pub fn new() -> XGBoost {
                ::std::default::Default::default()
            }

            // string name = 1;

            pub fn name(&self) -> &str {
                &self.name
            }

            pub fn clear_name(&mut self) {
                self.name.clear();
            }

            // Param is passed by value, moved
            pub fn set_name(&mut self, v: ::std::string::String) {
                self.name = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_name(&mut self) -> &mut ::std::string::String {
                &mut self.name
            }

            // Take field
            pub fn take_name(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.name, ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "name",
                    |m: &XGBoost| { &m.name },
                    |m: &mut XGBoost| { &mut m.name },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<XGBoost>(
                    "Transform.External.XGBoost",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for XGBoost {
            const NAME: &'static str = "XGBoost";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.name = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.name.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.name);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.name.is_empty() {
                    os.write_string(1, &self.name)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> XGBoost {
                XGBoost::new()
            }

            fn clear(&mut self) {
                self.name.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static XGBoost {
                static instance: XGBoost = XGBoost {
                    name: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for XGBoost {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Transform.External.XGBoost").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for XGBoost {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for XGBoost {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:Transform.External.Skopt)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Skopt {
            // message fields
            // @@protoc_insertion_point(field:Transform.External.Skopt.name)
            pub name: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:Transform.External.Skopt.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Skopt {
            fn default() -> &'a Skopt {
                <Skopt as ::protobuf::Message>::default_instance()
            }
        }

        impl Skopt {
            pub fn new() -> Skopt {
                ::std::default::Default::default()
            }

            // string name = 1;

            pub fn name(&self) -> &str {
                &self.name
            }

            pub fn clear_name(&mut self) {
                self.name.clear();
            }

            // Param is passed by value, moved
            pub fn set_name(&mut self, v: ::std::string::String) {
                self.name = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_name(&mut self) -> &mut ::std::string::String {
                &mut self.name
            }

            // Take field
            pub fn take_name(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.name, ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "name",
                    |m: &Skopt| { &m.name },
                    |m: &mut Skopt| { &mut m.name },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Skopt>(
                    "Transform.External.Skopt",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Skopt {
            const NAME: &'static str = "Skopt";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.name = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.name.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.name);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.name.is_empty() {
                    os.write_string(1, &self.name)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Skopt {
                Skopt::new()
            }

            fn clear(&mut self) {
                self.name.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Skopt {
                static instance: Skopt = Skopt {
                    name: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Skopt {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Transform.External.Skopt").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Skopt {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Skopt {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:Transform.External.Imblearn)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Imblearn {
            // message fields
            // @@protoc_insertion_point(field:Transform.External.Imblearn.name)
            pub name: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:Transform.External.Imblearn.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Imblearn {
            fn default() -> &'a Imblearn {
                <Imblearn as ::protobuf::Message>::default_instance()
            }
        }

        impl Imblearn {
            pub fn new() -> Imblearn {
                ::std::default::Default::default()
            }

            // string name = 1;

            pub fn name(&self) -> &str {
                &self.name
            }

            pub fn clear_name(&mut self) {
                self.name.clear();
            }

            // Param is passed by value, moved
            pub fn set_name(&mut self, v: ::std::string::String) {
                self.name = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_name(&mut self) -> &mut ::std::string::String {
                &mut self.name
            }

            // Take field
            pub fn take_name(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.name, ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "name",
                    |m: &Imblearn| { &m.name },
                    |m: &mut Imblearn| { &mut m.name },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Imblearn>(
                    "Transform.External.Imblearn",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Imblearn {
            const NAME: &'static str = "Imblearn";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.name = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.name.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.name);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.name.is_empty() {
                    os.write_string(1, &self.name)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Imblearn {
                Imblearn::new()
            }

            fn clear(&mut self) {
                self.name.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Imblearn {
                static instance: Imblearn = Imblearn {
                    name: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Imblearn {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Transform.External.Imblearn").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Imblearn {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Imblearn {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:Transform.Identity)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Identity {
        // special fields
        // @@protoc_insertion_point(special_field:Transform.Identity.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Identity {
        fn default() -> &'a Identity {
            <Identity as ::protobuf::Message>::default_instance()
        }
    }

    impl Identity {
        pub fn new() -> Identity {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Identity>(
                "Transform.Identity",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Identity {
        const NAME: &'static str = "Identity";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Identity {
            Identity::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Identity {
            static instance: Identity = Identity {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Identity {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.Identity").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Identity {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Identity {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.Variable)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Variable {
        // message fields
        // @@protoc_insertion_point(field:Transform.Variable.position)
        pub position: i32,
        // @@protoc_insertion_point(field:Transform.Variable.name)
        pub name: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:Transform.Variable.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Variable {
        fn default() -> &'a Variable {
            <Variable as ::protobuf::Message>::default_instance()
        }
    }

    impl Variable {
        pub fn new() -> Variable {
            ::std::default::Default::default()
        }

        // int32 position = 1;

        pub fn position(&self) -> i32 {
            self.position
        }

        pub fn clear_position(&mut self) {
            self.position = 0;
        }

        // Param is passed by value, moved
        pub fn set_position(&mut self, v: i32) {
            self.position = v;
        }

        // string name = 2;

        pub fn name(&self) -> &str {
            &self.name
        }

        pub fn clear_name(&mut self) {
            self.name.clear();
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            &mut self.name
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.name, ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "position",
                |m: &Variable| { &m.position },
                |m: &mut Variable| { &mut m.position },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "name",
                |m: &Variable| { &m.name },
                |m: &mut Variable| { &mut m.name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Variable>(
                "Transform.Variable",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Variable {
        const NAME: &'static str = "Variable";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.position = is.read_int32()?;
                    },
                    18 => {
                        self.name = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.position != 0 {
                my_size += ::protobuf::rt::int32_size(1, self.position);
            }
            if !self.name.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.name);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.position != 0 {
                os.write_int32(1, self.position)?;
            }
            if !self.name.is_empty() {
                os.write_string(2, &self.name)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Variable {
            Variable::new()
        }

        fn clear(&mut self) {
            self.position = 0;
            self.name.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Variable {
            static instance: Variable = Variable {
                position: 0,
                name: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Variable {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.Variable").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Variable {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Variable {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.Composed)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Composed {
        // message fields
        // @@protoc_insertion_point(field:Transform.Composed.transform)
        pub transform: ::std::string::String,
        // @@protoc_insertion_point(field:Transform.Composed.arguments)
        pub arguments: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:Transform.Composed.named_arguments)
        pub named_arguments: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:Transform.Composed.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Composed {
        fn default() -> &'a Composed {
            <Composed as ::protobuf::Message>::default_instance()
        }
    }

    impl Composed {
        pub fn new() -> Composed {
            ::std::default::Default::default()
        }

        // string transform = 1;

        pub fn transform(&self) -> &str {
            &self.transform
        }

        pub fn clear_transform(&mut self) {
            self.transform.clear();
        }

        // Param is passed by value, moved
        pub fn set_transform(&mut self, v: ::std::string::String) {
            self.transform = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_transform(&mut self) -> &mut ::std::string::String {
            &mut self.transform
        }

        // Take field
        pub fn take_transform(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.transform, ::std::string::String::new())
        }

        // repeated string arguments = 2;

        pub fn arguments(&self) -> &[::std::string::String] {
            &self.arguments
        }

        pub fn clear_arguments(&mut self) {
            self.arguments.clear();
        }

        // Param is passed by value, moved
        pub fn set_arguments(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.arguments = v;
        }

        // Mutable pointer to the field.
        pub fn mut_arguments(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.arguments
        }

        // Take field
        pub fn take_arguments(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.arguments, ::std::vec::Vec::new())
        }

        // repeated .Transform.Composed.NamedArgumentsEntry named_arguments = 3;

        pub fn named_arguments(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.named_arguments
        }

        pub fn clear_named_arguments(&mut self) {
            self.named_arguments.clear();
        }

        // Param is passed by value, moved
        pub fn set_named_arguments(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.named_arguments = v;
        }

        // Mutable pointer to the field.
        pub fn mut_named_arguments(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.named_arguments
        }

        // Take field
        pub fn take_named_arguments(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.named_arguments, ::std::collections::HashMap::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "transform",
                |m: &Composed| { &m.transform },
                |m: &mut Composed| { &mut m.transform },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "arguments",
                |m: &Composed| { &m.arguments },
                |m: &mut Composed| { &mut m.arguments },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
                "named_arguments",
                |m: &Composed| { &m.named_arguments },
                |m: &mut Composed| { &mut m.named_arguments },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Composed>(
                "Transform.Composed",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Composed {
        const NAME: &'static str = "Composed";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.transform = is.read_string()?;
                    },
                    18 => {
                        self.arguments.push(is.read_string()?);
                    },
                    26 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.named_arguments.insert(key, value);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.transform.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.transform);
            }
            for value in &self.arguments {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            for (k, v) in &self.named_arguments {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.transform.is_empty() {
                os.write_string(1, &self.transform)?;
            }
            for v in &self.arguments {
                os.write_string(2, &v)?;
            };
            for (k, v) in &self.named_arguments {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(26)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Composed {
            Composed::new()
        }

        fn clear(&mut self) {
            self.transform.clear();
            self.arguments.clear();
            self.named_arguments.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Composed {
            static instance: ::protobuf::rt::Lazy<Composed> = ::protobuf::rt::Lazy::new();
            instance.get(Composed::new)
        }
    }

    impl ::protobuf::MessageFull for Composed {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.Composed").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Composed {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Composed {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.Project)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Project {
        // message fields
        // @@protoc_insertion_point(field:Transform.Project.projection)
        pub projection: ::protobuf::MessageField<super::super::type_::Type>,
        // special fields
        // @@protoc_insertion_point(special_field:Transform.Project.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Project {
        fn default() -> &'a Project {
            <Project as ::protobuf::Message>::default_instance()
        }
    }

    impl Project {
        pub fn new() -> Project {
            ::std::default::Default::default()
        }

        // .sarus_data_spec.Type projection = 1;

        pub fn projection(&self) -> &super::super::type_::Type {
            self.projection.as_ref().unwrap_or_else(|| <super::super::type_::Type as ::protobuf::Message>::default_instance())
        }

        pub fn clear_projection(&mut self) {
            self.projection.clear();
        }

        pub fn has_projection(&self) -> bool {
            self.projection.is_some()
        }

        // Param is passed by value, moved
        pub fn set_projection(&mut self, v: super::super::type_::Type) {
            self.projection = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_projection(&mut self) -> &mut super::super::type_::Type {
            self.projection.mut_or_insert_default()
        }

        // Take field
        pub fn take_projection(&mut self) -> super::super::type_::Type {
            self.projection.take().unwrap_or_else(|| super::super::type_::Type::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::type_::Type>(
                "projection",
                |m: &Project| { &m.projection },
                |m: &mut Project| { &mut m.projection },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Project>(
                "Transform.Project",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Project {
        const NAME: &'static str = "Project";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.projection)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.projection.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.projection.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Project {
            Project::new()
        }

        fn clear(&mut self) {
            self.projection.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Project {
            static instance: Project = Project {
                projection: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Project {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.Project").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Project {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Project {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.Filter)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Filter {
        // message fields
        // @@protoc_insertion_point(field:Transform.Filter.filter)
        pub filter: ::protobuf::MessageField<super::super::type_::Type>,
        // special fields
        // @@protoc_insertion_point(special_field:Transform.Filter.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Filter {
        fn default() -> &'a Filter {
            <Filter as ::protobuf::Message>::default_instance()
        }
    }

    impl Filter {
        pub fn new() -> Filter {
            ::std::default::Default::default()
        }

        // .sarus_data_spec.Type filter = 1;

        pub fn filter(&self) -> &super::super::type_::Type {
            self.filter.as_ref().unwrap_or_else(|| <super::super::type_::Type as ::protobuf::Message>::default_instance())
        }

        pub fn clear_filter(&mut self) {
            self.filter.clear();
        }

        pub fn has_filter(&self) -> bool {
            self.filter.is_some()
        }

        // Param is passed by value, moved
        pub fn set_filter(&mut self, v: super::super::type_::Type) {
            self.filter = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_filter(&mut self) -> &mut super::super::type_::Type {
            self.filter.mut_or_insert_default()
        }

        // Take field
        pub fn take_filter(&mut self) -> super::super::type_::Type {
            self.filter.take().unwrap_or_else(|| super::super::type_::Type::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::type_::Type>(
                "filter",
                |m: &Filter| { &m.filter },
                |m: &mut Filter| { &mut m.filter },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Filter>(
                "Transform.Filter",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Filter {
        const NAME: &'static str = "Filter";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.filter)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.filter.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.filter.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Filter {
            Filter::new()
        }

        fn clear(&mut self) {
            self.filter.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Filter {
            static instance: Filter = Filter {
                filter: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Filter {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.Filter").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Filter {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Filter {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.Shuffle)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Shuffle {
        // special fields
        // @@protoc_insertion_point(special_field:Transform.Shuffle.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Shuffle {
        fn default() -> &'a Shuffle {
            <Shuffle as ::protobuf::Message>::default_instance()
        }
    }

    impl Shuffle {
        pub fn new() -> Shuffle {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Shuffle>(
                "Transform.Shuffle",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Shuffle {
        const NAME: &'static str = "Shuffle";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Shuffle {
            Shuffle::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Shuffle {
            static instance: Shuffle = Shuffle {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Shuffle {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.Shuffle").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Shuffle {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Shuffle {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.Join)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Join {
        // message fields
        // @@protoc_insertion_point(field:Transform.Join.on)
        pub on: ::protobuf::MessageField<super::super::type_::Type>,
        // special fields
        // @@protoc_insertion_point(special_field:Transform.Join.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Join {
        fn default() -> &'a Join {
            <Join as ::protobuf::Message>::default_instance()
        }
    }

    impl Join {
        pub fn new() -> Join {
            ::std::default::Default::default()
        }

        // .sarus_data_spec.Type on = 1;

        pub fn on(&self) -> &super::super::type_::Type {
            self.on.as_ref().unwrap_or_else(|| <super::super::type_::Type as ::protobuf::Message>::default_instance())
        }

        pub fn clear_on(&mut self) {
            self.on.clear();
        }

        pub fn has_on(&self) -> bool {
            self.on.is_some()
        }

        // Param is passed by value, moved
        pub fn set_on(&mut self, v: super::super::type_::Type) {
            self.on = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_on(&mut self) -> &mut super::super::type_::Type {
            self.on.mut_or_insert_default()
        }

        // Take field
        pub fn take_on(&mut self) -> super::super::type_::Type {
            self.on.take().unwrap_or_else(|| super::super::type_::Type::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::type_::Type>(
                "on",
                |m: &Join| { &m.on },
                |m: &mut Join| { &mut m.on },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Join>(
                "Transform.Join",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Join {
        const NAME: &'static str = "Join";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.on)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.on.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.on.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Join {
            Join::new()
        }

        fn clear(&mut self) {
            self.on.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Join {
            static instance: Join = Join {
                on: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Join {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.Join").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Join {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Join {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.Cast)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Cast {
        // message fields
        // @@protoc_insertion_point(field:Transform.Cast.type)
        pub type_: ::protobuf::MessageField<super::super::type_::Type>,
        // special fields
        // @@protoc_insertion_point(special_field:Transform.Cast.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Cast {
        fn default() -> &'a Cast {
            <Cast as ::protobuf::Message>::default_instance()
        }
    }

    impl Cast {
        pub fn new() -> Cast {
            ::std::default::Default::default()
        }

        // .sarus_data_spec.Type type = 1;

        pub fn type_(&self) -> &super::super::type_::Type {
            self.type_.as_ref().unwrap_or_else(|| <super::super::type_::Type as ::protobuf::Message>::default_instance())
        }

        pub fn clear_type_(&mut self) {
            self.type_.clear();
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: super::super::type_::Type) {
            self.type_ = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_type(&mut self) -> &mut super::super::type_::Type {
            self.type_.mut_or_insert_default()
        }

        // Take field
        pub fn take_type_(&mut self) -> super::super::type_::Type {
            self.type_.take().unwrap_or_else(|| super::super::type_::Type::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::type_::Type>(
                "type",
                |m: &Cast| { &m.type_ },
                |m: &mut Cast| { &mut m.type_ },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Cast>(
                "Transform.Cast",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Cast {
        const NAME: &'static str = "Cast";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.type_)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Cast {
            Cast::new()
        }

        fn clear(&mut self) {
            self.type_.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Cast {
            static instance: Cast = Cast {
                type_: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Cast {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.Cast").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Cast {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Cast {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.Sample)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Sample {
        // message fields
        // @@protoc_insertion_point(field:Transform.Sample.seed)
        pub seed: ::protobuf::MessageField<super::super::scalar::Scalar>,
        // message oneof groups
        pub proportion: ::std::option::Option<sample::Proportion>,
        // special fields
        // @@protoc_insertion_point(special_field:Transform.Sample.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Sample {
        fn default() -> &'a Sample {
            <Sample as ::protobuf::Message>::default_instance()
        }
    }

    impl Sample {
        pub fn new() -> Sample {
            ::std::default::Default::default()
        }

        // double fraction = 1;

        pub fn fraction(&self) -> f64 {
            match self.proportion {
                ::std::option::Option::Some(sample::Proportion::Fraction(v)) => v,
                _ => 0.,
            }
        }

        pub fn clear_fraction(&mut self) {
            self.proportion = ::std::option::Option::None;
        }

        pub fn has_fraction(&self) -> bool {
            match self.proportion {
                ::std::option::Option::Some(sample::Proportion::Fraction(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_fraction(&mut self, v: f64) {
            self.proportion = ::std::option::Option::Some(sample::Proportion::Fraction(v))
        }

        // int64 size = 2;

        pub fn size(&self) -> i64 {
            match self.proportion {
                ::std::option::Option::Some(sample::Proportion::Size(v)) => v,
                _ => 0,
            }
        }

        pub fn clear_size(&mut self) {
            self.proportion = ::std::option::Option::None;
        }

        pub fn has_size(&self) -> bool {
            match self.proportion {
                ::std::option::Option::Some(sample::Proportion::Size(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_size(&mut self, v: i64) {
            self.proportion = ::std::option::Option::Some(sample::Proportion::Size(v))
        }

        // .sarus_data_spec.Scalar seed = 3;

        pub fn seed(&self) -> &super::super::scalar::Scalar {
            self.seed.as_ref().unwrap_or_else(|| <super::super::scalar::Scalar as ::protobuf::Message>::default_instance())
        }

        pub fn clear_seed(&mut self) {
            self.seed.clear();
        }

        pub fn has_seed(&self) -> bool {
            self.seed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_seed(&mut self, v: super::super::scalar::Scalar) {
            self.seed = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_seed(&mut self) -> &mut super::super::scalar::Scalar {
            self.seed.mut_or_insert_default()
        }

        // Take field
        pub fn take_seed(&mut self) -> super::super::scalar::Scalar {
            self.seed.take().unwrap_or_else(|| super::super::scalar::Scalar::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
                "fraction",
                Sample::has_fraction,
                Sample::fraction,
                Sample::set_fraction,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
                "size",
                Sample::has_size,
                Sample::size,
                Sample::set_size,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::scalar::Scalar>(
                "seed",
                |m: &Sample| { &m.seed },
                |m: &mut Sample| { &mut m.seed },
            ));
            oneofs.push(sample::Proportion::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Sample>(
                "Transform.Sample",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Sample {
        const NAME: &'static str = "Sample";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.proportion = ::std::option::Option::Some(sample::Proportion::Fraction(is.read_double()?));
                    },
                    16 => {
                        self.proportion = ::std::option::Option::Some(sample::Proportion::Size(is.read_int64()?));
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.seed)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.seed.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let ::std::option::Option::Some(ref v) = self.proportion {
                match v {
                    &sample::Proportion::Fraction(v) => {
                        my_size += 1 + 8;
                    },
                    &sample::Proportion::Size(v) => {
                        my_size += ::protobuf::rt::int64_size(2, v);
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.seed.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let ::std::option::Option::Some(ref v) = self.proportion {
                match v {
                    &sample::Proportion::Fraction(v) => {
                        os.write_double(1, v)?;
                    },
                    &sample::Proportion::Size(v) => {
                        os.write_int64(2, v)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Sample {
            Sample::new()
        }

        fn clear(&mut self) {
            self.proportion = ::std::option::Option::None;
            self.proportion = ::std::option::Option::None;
            self.seed.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Sample {
            static instance: Sample = Sample {
                seed: ::protobuf::MessageField::none(),
                proportion: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Sample {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.Sample").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Sample {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Sample {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Sample`
    pub mod sample {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:Transform.Sample.proportion)
        pub enum Proportion {
            // @@protoc_insertion_point(oneof_field:Transform.Sample.fraction)
            Fraction(f64),
            // @@protoc_insertion_point(oneof_field:Transform.Sample.size)
            Size(i64),
        }

        impl ::protobuf::Oneof for Proportion {
        }

        impl ::protobuf::OneofFull for Proportion {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::Sample as ::protobuf::MessageFull>::descriptor().oneof_by_name("proportion").unwrap()).clone()
            }
        }

        impl Proportion {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Proportion>("proportion")
            }
        }
    }

    // @@protoc_insertion_point(message:Transform.SchemaInference)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SchemaInference {
        // message fields
        // @@protoc_insertion_point(field:Transform.SchemaInference.cast_policy)
        pub cast_policy: ::protobuf::EnumOrUnknown<schema_inference::CastPolicy>,
        // special fields
        // @@protoc_insertion_point(special_field:Transform.SchemaInference.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SchemaInference {
        fn default() -> &'a SchemaInference {
            <SchemaInference as ::protobuf::Message>::default_instance()
        }
    }

    impl SchemaInference {
        pub fn new() -> SchemaInference {
            ::std::default::Default::default()
        }

        // .Transform.SchemaInference.CastPolicy cast_policy = 1;

        pub fn cast_policy(&self) -> schema_inference::CastPolicy {
            self.cast_policy.enum_value_or_default()
        }

        pub fn clear_cast_policy(&mut self) {
            self.cast_policy = ::protobuf::EnumOrUnknown::new(schema_inference::CastPolicy::NONE);
        }

        // Param is passed by value, moved
        pub fn set_cast_policy(&mut self, v: schema_inference::CastPolicy) {
            self.cast_policy = ::protobuf::EnumOrUnknown::new(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "cast_policy",
                |m: &SchemaInference| { &m.cast_policy },
                |m: &mut SchemaInference| { &mut m.cast_policy },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SchemaInference>(
                "Transform.SchemaInference",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SchemaInference {
        const NAME: &'static str = "SchemaInference";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.cast_policy = is.read_enum_or_unknown()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.cast_policy != ::protobuf::EnumOrUnknown::new(schema_inference::CastPolicy::NONE) {
                my_size += ::protobuf::rt::int32_size(1, self.cast_policy.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.cast_policy != ::protobuf::EnumOrUnknown::new(schema_inference::CastPolicy::NONE) {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.cast_policy))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SchemaInference {
            SchemaInference::new()
        }

        fn clear(&mut self) {
            self.cast_policy = ::protobuf::EnumOrUnknown::new(schema_inference::CastPolicy::NONE);
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SchemaInference {
            static instance: SchemaInference = SchemaInference {
                cast_policy: ::protobuf::EnumOrUnknown::from_i32(0),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SchemaInference {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.SchemaInference").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SchemaInference {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SchemaInference {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `SchemaInference`
    pub mod schema_inference {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:Transform.SchemaInference.CastPolicy)
        pub enum CastPolicy {
            // @@protoc_insertion_point(enum_value:Transform.SchemaInference.CastPolicy.NONE)
            NONE = 0,
            // @@protoc_insertion_point(enum_value:Transform.SchemaInference.CastPolicy.MOST_LIKELY)
            MOST_LIKELY = 1,
        }

        impl ::protobuf::Enum for CastPolicy {
            const NAME: &'static str = "CastPolicy";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<CastPolicy> {
                match value {
                    0 => ::std::option::Option::Some(CastPolicy::NONE),
                    1 => ::std::option::Option::Some(CastPolicy::MOST_LIKELY),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<CastPolicy> {
                match str {
                    "NONE" => ::std::option::Option::Some(CastPolicy::NONE),
                    "MOST_LIKELY" => ::std::option::Option::Some(CastPolicy::MOST_LIKELY),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [CastPolicy] = &[
                CastPolicy::NONE,
                CastPolicy::MOST_LIKELY,
            ];
        }

        impl ::protobuf::EnumFull for CastPolicy {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("Transform.SchemaInference.CastPolicy").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for CastPolicy {
            fn default() -> Self {
                CastPolicy::NONE
            }
        }

        impl CastPolicy {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CastPolicy>("Transform.SchemaInference.CastPolicy")
            }
        }
    }

    // @@protoc_insertion_point(message:Transform.GroupBy)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GroupBy {
        // message fields
        // @@protoc_insertion_point(field:Transform.GroupBy.key)
        pub key: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:Transform.GroupBy.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GroupBy {
        fn default() -> &'a GroupBy {
            <GroupBy as ::protobuf::Message>::default_instance()
        }
    }

    impl GroupBy {
        pub fn new() -> GroupBy {
            ::std::default::Default::default()
        }

        // string key = 1;

        pub fn key(&self) -> &str {
            &self.key
        }

        pub fn clear_key(&mut self) {
            self.key.clear();
        }

        // Param is passed by value, moved
        pub fn set_key(&mut self, v: ::std::string::String) {
            self.key = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_key(&mut self) -> &mut ::std::string::String {
            &mut self.key
        }

        // Take field
        pub fn take_key(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.key, ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "key",
                |m: &GroupBy| { &m.key },
                |m: &mut GroupBy| { &mut m.key },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupBy>(
                "Transform.GroupBy",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GroupBy {
        const NAME: &'static str = "GroupBy";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.key = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.key.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.key);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.key.is_empty() {
                os.write_string(1, &self.key)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GroupBy {
            GroupBy::new()
        }

        fn clear(&mut self) {
            self.key.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GroupBy {
            static instance: GroupBy = GroupBy {
                key: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GroupBy {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.GroupBy").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GroupBy {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GroupBy {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.Synthetic)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Synthetic {
        // special fields
        // @@protoc_insertion_point(special_field:Transform.Synthetic.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Synthetic {
        fn default() -> &'a Synthetic {
            <Synthetic as ::protobuf::Message>::default_instance()
        }
    }

    impl Synthetic {
        pub fn new() -> Synthetic {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Synthetic>(
                "Transform.Synthetic",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Synthetic {
        const NAME: &'static str = "Synthetic";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Synthetic {
            Synthetic::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Synthetic {
            static instance: Synthetic = Synthetic {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Synthetic {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.Synthetic").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Synthetic {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Synthetic {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.UserSettings)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UserSettings {
        // special fields
        // @@protoc_insertion_point(special_field:Transform.UserSettings.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UserSettings {
        fn default() -> &'a UserSettings {
            <UserSettings as ::protobuf::Message>::default_instance()
        }
    }

    impl UserSettings {
        pub fn new() -> UserSettings {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserSettings>(
                "Transform.UserSettings",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for UserSettings {
        const NAME: &'static str = "UserSettings";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UserSettings {
            UserSettings::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UserSettings {
            static instance: UserSettings = UserSettings {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for UserSettings {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.UserSettings").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UserSettings {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UserSettings {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.AutomaticUserSettings)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AutomaticUserSettings {
        // message fields
        // @@protoc_insertion_point(field:Transform.AutomaticUserSettings.max_categories)
        pub max_categories: i64,
        // special fields
        // @@protoc_insertion_point(special_field:Transform.AutomaticUserSettings.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AutomaticUserSettings {
        fn default() -> &'a AutomaticUserSettings {
            <AutomaticUserSettings as ::protobuf::Message>::default_instance()
        }
    }

    impl AutomaticUserSettings {
        pub fn new() -> AutomaticUserSettings {
            ::std::default::Default::default()
        }

        // int64 max_categories = 1;

        pub fn max_categories(&self) -> i64 {
            self.max_categories
        }

        pub fn clear_max_categories(&mut self) {
            self.max_categories = 0;
        }

        // Param is passed by value, moved
        pub fn set_max_categories(&mut self, v: i64) {
            self.max_categories = v;
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "max_categories",
                |m: &AutomaticUserSettings| { &m.max_categories },
                |m: &mut AutomaticUserSettings| { &mut m.max_categories },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AutomaticUserSettings>(
                "Transform.AutomaticUserSettings",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AutomaticUserSettings {
        const NAME: &'static str = "AutomaticUserSettings";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.max_categories = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.max_categories != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.max_categories);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.max_categories != 0 {
                os.write_int64(1, self.max_categories)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AutomaticUserSettings {
            AutomaticUserSettings::new()
        }

        fn clear(&mut self) {
            self.max_categories = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AutomaticUserSettings {
            static instance: AutomaticUserSettings = AutomaticUserSettings {
                max_categories: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AutomaticUserSettings {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.AutomaticUserSettings").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AutomaticUserSettings {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AutomaticUserSettings {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.Protect)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Protect {
        // special fields
        // @@protoc_insertion_point(special_field:Transform.Protect.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Protect {
        fn default() -> &'a Protect {
            <Protect as ::protobuf::Message>::default_instance()
        }
    }

    impl Protect {
        pub fn new() -> Protect {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Protect>(
                "Transform.Protect",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Protect {
        const NAME: &'static str = "Protect";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Protect {
            Protect::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Protect {
            static instance: Protect = Protect {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Protect {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.Protect").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Protect {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Protect {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.Transcode)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Transcode {
        // special fields
        // @@protoc_insertion_point(special_field:Transform.Transcode.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Transcode {
        fn default() -> &'a Transcode {
            <Transcode as ::protobuf::Message>::default_instance()
        }
    }

    impl Transcode {
        pub fn new() -> Transcode {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Transcode>(
                "Transform.Transcode",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Transcode {
        const NAME: &'static str = "Transcode";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Transcode {
            Transcode::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Transcode {
            static instance: Transcode = Transcode {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Transcode {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.Transcode").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Transcode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Transcode {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.InverseTranscode)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct InverseTranscode {
        // special fields
        // @@protoc_insertion_point(special_field:Transform.InverseTranscode.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a InverseTranscode {
        fn default() -> &'a InverseTranscode {
            <InverseTranscode as ::protobuf::Message>::default_instance()
        }
    }

    impl InverseTranscode {
        pub fn new() -> InverseTranscode {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InverseTranscode>(
                "Transform.InverseTranscode",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for InverseTranscode {
        const NAME: &'static str = "InverseTranscode";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> InverseTranscode {
            InverseTranscode::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static InverseTranscode {
            static instance: InverseTranscode = InverseTranscode {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for InverseTranscode {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.InverseTranscode").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for InverseTranscode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for InverseTranscode {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.DifferentiatedSample)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DifferentiatedSample {
        // message fields
        // @@protoc_insertion_point(field:Transform.DifferentiatedSample.seed)
        pub seed: ::protobuf::MessageField<super::super::scalar::Scalar>,
        // message oneof groups
        pub proportion: ::std::option::Option<differentiated_sample::Proportion>,
        // special fields
        // @@protoc_insertion_point(special_field:Transform.DifferentiatedSample.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DifferentiatedSample {
        fn default() -> &'a DifferentiatedSample {
            <DifferentiatedSample as ::protobuf::Message>::default_instance()
        }
    }

    impl DifferentiatedSample {
        pub fn new() -> DifferentiatedSample {
            ::std::default::Default::default()
        }

        // double fraction = 1;

        pub fn fraction(&self) -> f64 {
            match self.proportion {
                ::std::option::Option::Some(differentiated_sample::Proportion::Fraction(v)) => v,
                _ => 0.,
            }
        }

        pub fn clear_fraction(&mut self) {
            self.proportion = ::std::option::Option::None;
        }

        pub fn has_fraction(&self) -> bool {
            match self.proportion {
                ::std::option::Option::Some(differentiated_sample::Proportion::Fraction(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_fraction(&mut self, v: f64) {
            self.proportion = ::std::option::Option::Some(differentiated_sample::Proportion::Fraction(v))
        }

        // int64 size = 2;

        pub fn size(&self) -> i64 {
            match self.proportion {
                ::std::option::Option::Some(differentiated_sample::Proportion::Size(v)) => v,
                _ => 0,
            }
        }

        pub fn clear_size(&mut self) {
            self.proportion = ::std::option::Option::None;
        }

        pub fn has_size(&self) -> bool {
            match self.proportion {
                ::std::option::Option::Some(differentiated_sample::Proportion::Size(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_size(&mut self, v: i64) {
            self.proportion = ::std::option::Option::Some(differentiated_sample::Proportion::Size(v))
        }

        // .sarus_data_spec.Scalar seed = 3;

        pub fn seed(&self) -> &super::super::scalar::Scalar {
            self.seed.as_ref().unwrap_or_else(|| <super::super::scalar::Scalar as ::protobuf::Message>::default_instance())
        }

        pub fn clear_seed(&mut self) {
            self.seed.clear();
        }

        pub fn has_seed(&self) -> bool {
            self.seed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_seed(&mut self, v: super::super::scalar::Scalar) {
            self.seed = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_seed(&mut self) -> &mut super::super::scalar::Scalar {
            self.seed.mut_or_insert_default()
        }

        // Take field
        pub fn take_seed(&mut self) -> super::super::scalar::Scalar {
            self.seed.take().unwrap_or_else(|| super::super::scalar::Scalar::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
                "fraction",
                DifferentiatedSample::has_fraction,
                DifferentiatedSample::fraction,
                DifferentiatedSample::set_fraction,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
                "size",
                DifferentiatedSample::has_size,
                DifferentiatedSample::size,
                DifferentiatedSample::set_size,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::scalar::Scalar>(
                "seed",
                |m: &DifferentiatedSample| { &m.seed },
                |m: &mut DifferentiatedSample| { &mut m.seed },
            ));
            oneofs.push(differentiated_sample::Proportion::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DifferentiatedSample>(
                "Transform.DifferentiatedSample",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DifferentiatedSample {
        const NAME: &'static str = "DifferentiatedSample";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.proportion = ::std::option::Option::Some(differentiated_sample::Proportion::Fraction(is.read_double()?));
                    },
                    16 => {
                        self.proportion = ::std::option::Option::Some(differentiated_sample::Proportion::Size(is.read_int64()?));
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.seed)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.seed.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let ::std::option::Option::Some(ref v) = self.proportion {
                match v {
                    &differentiated_sample::Proportion::Fraction(v) => {
                        my_size += 1 + 8;
                    },
                    &differentiated_sample::Proportion::Size(v) => {
                        my_size += ::protobuf::rt::int64_size(2, v);
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.seed.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let ::std::option::Option::Some(ref v) = self.proportion {
                match v {
                    &differentiated_sample::Proportion::Fraction(v) => {
                        os.write_double(1, v)?;
                    },
                    &differentiated_sample::Proportion::Size(v) => {
                        os.write_int64(2, v)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DifferentiatedSample {
            DifferentiatedSample::new()
        }

        fn clear(&mut self) {
            self.proportion = ::std::option::Option::None;
            self.proportion = ::std::option::Option::None;
            self.seed.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DifferentiatedSample {
            static instance: DifferentiatedSample = DifferentiatedSample {
                seed: ::protobuf::MessageField::none(),
                proportion: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DifferentiatedSample {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.DifferentiatedSample").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DifferentiatedSample {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DifferentiatedSample {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `DifferentiatedSample`
    pub mod differentiated_sample {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:Transform.DifferentiatedSample.proportion)
        pub enum Proportion {
            // @@protoc_insertion_point(oneof_field:Transform.DifferentiatedSample.fraction)
            Fraction(f64),
            // @@protoc_insertion_point(oneof_field:Transform.DifferentiatedSample.size)
            Size(i64),
        }

        impl ::protobuf::Oneof for Proportion {
        }

        impl ::protobuf::OneofFull for Proportion {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::DifferentiatedSample as ::protobuf::MessageFull>::descriptor().oneof_by_name("proportion").unwrap()).clone()
            }
        }

        impl Proportion {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Proportion>("proportion")
            }
        }
    }

    // @@protoc_insertion_point(message:Transform.ProtectedPaths)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ProtectedPaths {
        // special fields
        // @@protoc_insertion_point(special_field:Transform.ProtectedPaths.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ProtectedPaths {
        fn default() -> &'a ProtectedPaths {
            <ProtectedPaths as ::protobuf::Message>::default_instance()
        }
    }

    impl ProtectedPaths {
        pub fn new() -> ProtectedPaths {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtectedPaths>(
                "Transform.ProtectedPaths",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ProtectedPaths {
        const NAME: &'static str = "ProtectedPaths";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ProtectedPaths {
            ProtectedPaths::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ProtectedPaths {
            static instance: ProtectedPaths = ProtectedPaths {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ProtectedPaths {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.ProtectedPaths").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ProtectedPaths {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ProtectedPaths {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.PublicPaths)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PublicPaths {
        // special fields
        // @@protoc_insertion_point(special_field:Transform.PublicPaths.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PublicPaths {
        fn default() -> &'a PublicPaths {
            <PublicPaths as ::protobuf::Message>::default_instance()
        }
    }

    impl PublicPaths {
        pub fn new() -> PublicPaths {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PublicPaths>(
                "Transform.PublicPaths",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PublicPaths {
        const NAME: &'static str = "PublicPaths";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PublicPaths {
            PublicPaths::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PublicPaths {
            static instance: PublicPaths = PublicPaths {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PublicPaths {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.PublicPaths").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PublicPaths {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PublicPaths {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.GetItem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GetItem {
        // message fields
        // @@protoc_insertion_point(field:Transform.GetItem.path)
        pub path: ::protobuf::MessageField<super::super::path::Path>,
        // special fields
        // @@protoc_insertion_point(special_field:Transform.GetItem.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GetItem {
        fn default() -> &'a GetItem {
            <GetItem as ::protobuf::Message>::default_instance()
        }
    }

    impl GetItem {
        pub fn new() -> GetItem {
            ::std::default::Default::default()
        }

        // .sarus_data_spec.Path path = 1;

        pub fn path(&self) -> &super::super::path::Path {
            self.path.as_ref().unwrap_or_else(|| <super::super::path::Path as ::protobuf::Message>::default_instance())
        }

        pub fn clear_path(&mut self) {
            self.path.clear();
        }

        pub fn has_path(&self) -> bool {
            self.path.is_some()
        }

        // Param is passed by value, moved
        pub fn set_path(&mut self, v: super::super::path::Path) {
            self.path = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_path(&mut self) -> &mut super::super::path::Path {
            self.path.mut_or_insert_default()
        }

        // Take field
        pub fn take_path(&mut self) -> super::super::path::Path {
            self.path.take().unwrap_or_else(|| super::super::path::Path::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::path::Path>(
                "path",
                |m: &GetItem| { &m.path },
                |m: &mut GetItem| { &mut m.path },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetItem>(
                "Transform.GetItem",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GetItem {
        const NAME: &'static str = "GetItem";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.path)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.path.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.path.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GetItem {
            GetItem::new()
        }

        fn clear(&mut self) {
            self.path.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GetItem {
            static instance: GetItem = GetItem {
                path: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GetItem {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.GetItem").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GetItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GetItem {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.AssignBudget)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AssignBudget {
        // special fields
        // @@protoc_insertion_point(special_field:Transform.AssignBudget.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AssignBudget {
        fn default() -> &'a AssignBudget {
            <AssignBudget as ::protobuf::Message>::default_instance()
        }
    }

    impl AssignBudget {
        pub fn new() -> AssignBudget {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AssignBudget>(
                "Transform.AssignBudget",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AssignBudget {
        const NAME: &'static str = "AssignBudget";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AssignBudget {
            AssignBudget::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AssignBudget {
            static instance: AssignBudget = AssignBudget {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AssignBudget {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.AssignBudget").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AssignBudget {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AssignBudget {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.AutomaticBudget)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AutomaticBudget {
        // special fields
        // @@protoc_insertion_point(special_field:Transform.AutomaticBudget.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AutomaticBudget {
        fn default() -> &'a AutomaticBudget {
            <AutomaticBudget as ::protobuf::Message>::default_instance()
        }
    }

    impl AutomaticBudget {
        pub fn new() -> AutomaticBudget {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AutomaticBudget>(
                "Transform.AutomaticBudget",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AutomaticBudget {
        const NAME: &'static str = "AutomaticBudget";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AutomaticBudget {
            AutomaticBudget::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AutomaticBudget {
            static instance: AutomaticBudget = AutomaticBudget {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AutomaticBudget {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.AutomaticBudget").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AutomaticBudget {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AutomaticBudget {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.AttributesBudget)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AttributesBudget {
        // special fields
        // @@protoc_insertion_point(special_field:Transform.AttributesBudget.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AttributesBudget {
        fn default() -> &'a AttributesBudget {
            <AttributesBudget as ::protobuf::Message>::default_instance()
        }
    }

    impl AttributesBudget {
        pub fn new() -> AttributesBudget {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AttributesBudget>(
                "Transform.AttributesBudget",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AttributesBudget {
        const NAME: &'static str = "AttributesBudget";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AttributesBudget {
            AttributesBudget::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AttributesBudget {
            static instance: AttributesBudget = AttributesBudget {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AttributesBudget {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.AttributesBudget").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AttributesBudget {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AttributesBudget {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.SDBudget)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SDBudget {
        // special fields
        // @@protoc_insertion_point(special_field:Transform.SDBudget.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SDBudget {
        fn default() -> &'a SDBudget {
            <SDBudget as ::protobuf::Message>::default_instance()
        }
    }

    impl SDBudget {
        pub fn new() -> SDBudget {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SDBudget>(
                "Transform.SDBudget",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SDBudget {
        const NAME: &'static str = "SDBudget";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SDBudget {
            SDBudget::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SDBudget {
            static instance: SDBudget = SDBudget {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SDBudget {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.SDBudget").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SDBudget {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SDBudget {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.DeriveSeed)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeriveSeed {
        // message fields
        // @@protoc_insertion_point(field:Transform.DeriveSeed.random_integer)
        pub random_integer: i64,
        // special fields
        // @@protoc_insertion_point(special_field:Transform.DeriveSeed.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeriveSeed {
        fn default() -> &'a DeriveSeed {
            <DeriveSeed as ::protobuf::Message>::default_instance()
        }
    }

    impl DeriveSeed {
        pub fn new() -> DeriveSeed {
            ::std::default::Default::default()
        }

        // int64 random_integer = 1;

        pub fn random_integer(&self) -> i64 {
            self.random_integer
        }

        pub fn clear_random_integer(&mut self) {
            self.random_integer = 0;
        }

        // Param is passed by value, moved
        pub fn set_random_integer(&mut self, v: i64) {
            self.random_integer = v;
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "random_integer",
                |m: &DeriveSeed| { &m.random_integer },
                |m: &mut DeriveSeed| { &mut m.random_integer },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeriveSeed>(
                "Transform.DeriveSeed",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DeriveSeed {
        const NAME: &'static str = "DeriveSeed";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.random_integer = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.random_integer != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.random_integer);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.random_integer != 0 {
                os.write_int64(1, self.random_integer)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeriveSeed {
            DeriveSeed::new()
        }

        fn clear(&mut self) {
            self.random_integer = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeriveSeed {
            static instance: DeriveSeed = DeriveSeed {
                random_integer: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DeriveSeed {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.DeriveSeed").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DeriveSeed {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DeriveSeed {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.GroupByPE)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GroupByPE {
        // special fields
        // @@protoc_insertion_point(special_field:Transform.GroupByPE.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GroupByPE {
        fn default() -> &'a GroupByPE {
            <GroupByPE as ::protobuf::Message>::default_instance()
        }
    }

    impl GroupByPE {
        pub fn new() -> GroupByPE {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupByPE>(
                "Transform.GroupByPE",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GroupByPE {
        const NAME: &'static str = "GroupByPE";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GroupByPE {
            GroupByPE::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GroupByPE {
            static instance: GroupByPE = GroupByPE {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GroupByPE {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.GroupByPE").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GroupByPE {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GroupByPE {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.SamplingRatios)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SamplingRatios {
        // special fields
        // @@protoc_insertion_point(special_field:Transform.SamplingRatios.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SamplingRatios {
        fn default() -> &'a SamplingRatios {
            <SamplingRatios as ::protobuf::Message>::default_instance()
        }
    }

    impl SamplingRatios {
        pub fn new() -> SamplingRatios {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SamplingRatios>(
                "Transform.SamplingRatios",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SamplingRatios {
        const NAME: &'static str = "SamplingRatios";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SamplingRatios {
            SamplingRatios::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SamplingRatios {
            static instance: SamplingRatios = SamplingRatios {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SamplingRatios {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.SamplingRatios").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SamplingRatios {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SamplingRatios {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.RelationshipSpec)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RelationshipSpec {
        // special fields
        // @@protoc_insertion_point(special_field:Transform.RelationshipSpec.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RelationshipSpec {
        fn default() -> &'a RelationshipSpec {
            <RelationshipSpec as ::protobuf::Message>::default_instance()
        }
    }

    impl RelationshipSpec {
        pub fn new() -> RelationshipSpec {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RelationshipSpec>(
                "Transform.RelationshipSpec",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RelationshipSpec {
        const NAME: &'static str = "RelationshipSpec";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RelationshipSpec {
            RelationshipSpec::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RelationshipSpec {
            static instance: RelationshipSpec = RelationshipSpec {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RelationshipSpec {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.RelationshipSpec").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RelationshipSpec {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RelationshipSpec {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.SelectSql)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SelectSql {
        // message fields
        // @@protoc_insertion_point(field:Transform.SelectSql.sql_dialect)
        pub sql_dialect: ::protobuf::EnumOrUnknown<SQLDialect>,
        // message oneof groups
        pub select: ::std::option::Option<select_sql::Select>,
        // special fields
        // @@protoc_insertion_point(special_field:Transform.SelectSql.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SelectSql {
        fn default() -> &'a SelectSql {
            <SelectSql as ::protobuf::Message>::default_instance()
        }
    }

    impl SelectSql {
        pub fn new() -> SelectSql {
            ::std::default::Default::default()
        }

        // string query = 1;

        pub fn query(&self) -> &str {
            match self.select {
                ::std::option::Option::Some(select_sql::Select::Query(ref v)) => v,
                _ => "",
            }
        }

        pub fn clear_query(&mut self) {
            self.select = ::std::option::Option::None;
        }

        pub fn has_query(&self) -> bool {
            match self.select {
                ::std::option::Option::Some(select_sql::Select::Query(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_query(&mut self, v: ::std::string::String) {
            self.select = ::std::option::Option::Some(select_sql::Select::Query(v))
        }

        // Mutable pointer to the field.
        pub fn mut_query(&mut self) -> &mut ::std::string::String {
            if let ::std::option::Option::Some(select_sql::Select::Query(_)) = self.select {
            } else {
                self.select = ::std::option::Option::Some(select_sql::Select::Query(::std::string::String::new()));
            }
            match self.select {
                ::std::option::Option::Some(select_sql::Select::Query(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_query(&mut self) -> ::std::string::String {
            if self.has_query() {
                match self.select.take() {
                    ::std::option::Option::Some(select_sql::Select::Query(v)) => v,
                    _ => panic!(),
                }
            } else {
                ::std::string::String::new()
            }
        }

        // .Transform.AliasedQueries aliased_queries = 2;

        pub fn aliased_queries(&self) -> &AliasedQueries {
            match self.select {
                ::std::option::Option::Some(select_sql::Select::AliasedQueries(ref v)) => v,
                _ => <AliasedQueries as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_aliased_queries(&mut self) {
            self.select = ::std::option::Option::None;
        }

        pub fn has_aliased_queries(&self) -> bool {
            match self.select {
                ::std::option::Option::Some(select_sql::Select::AliasedQueries(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_aliased_queries(&mut self, v: AliasedQueries) {
            self.select = ::std::option::Option::Some(select_sql::Select::AliasedQueries(v))
        }

        // Mutable pointer to the field.
        pub fn mut_aliased_queries(&mut self) -> &mut AliasedQueries {
            if let ::std::option::Option::Some(select_sql::Select::AliasedQueries(_)) = self.select {
            } else {
                self.select = ::std::option::Option::Some(select_sql::Select::AliasedQueries(AliasedQueries::new()));
            }
            match self.select {
                ::std::option::Option::Some(select_sql::Select::AliasedQueries(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_aliased_queries(&mut self) -> AliasedQueries {
            if self.has_aliased_queries() {
                match self.select.take() {
                    ::std::option::Option::Some(select_sql::Select::AliasedQueries(v)) => v,
                    _ => panic!(),
                }
            } else {
                AliasedQueries::new()
            }
        }

        // .Transform.SQLDialect sql_dialect = 3;

        pub fn sql_dialect(&self) -> SQLDialect {
            self.sql_dialect.enum_value_or_default()
        }

        pub fn clear_sql_dialect(&mut self) {
            self.sql_dialect = ::protobuf::EnumOrUnknown::new(SQLDialect::NONE);
        }

        // Param is passed by value, moved
        pub fn set_sql_dialect(&mut self, v: SQLDialect) {
            self.sql_dialect = ::protobuf::EnumOrUnknown::new(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
                "query",
                SelectSql::has_query,
                SelectSql::query,
                SelectSql::set_query,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, AliasedQueries>(
                "aliased_queries",
                SelectSql::has_aliased_queries,
                SelectSql::aliased_queries,
                SelectSql::mut_aliased_queries,
                SelectSql::set_aliased_queries,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "sql_dialect",
                |m: &SelectSql| { &m.sql_dialect },
                |m: &mut SelectSql| { &mut m.sql_dialect },
            ));
            oneofs.push(select_sql::Select::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelectSql>(
                "Transform.SelectSql",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SelectSql {
        const NAME: &'static str = "SelectSql";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.select = ::std::option::Option::Some(select_sql::Select::Query(is.read_string()?));
                    },
                    18 => {
                        self.select = ::std::option::Option::Some(select_sql::Select::AliasedQueries(is.read_message()?));
                    },
                    24 => {
                        self.sql_dialect = is.read_enum_or_unknown()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.sql_dialect != ::protobuf::EnumOrUnknown::new(SQLDialect::NONE) {
                my_size += ::protobuf::rt::int32_size(3, self.sql_dialect.value());
            }
            if let ::std::option::Option::Some(ref v) = self.select {
                match v {
                    &select_sql::Select::Query(ref v) => {
                        my_size += ::protobuf::rt::string_size(1, &v);
                    },
                    &select_sql::Select::AliasedQueries(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.sql_dialect != ::protobuf::EnumOrUnknown::new(SQLDialect::NONE) {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.sql_dialect))?;
            }
            if let ::std::option::Option::Some(ref v) = self.select {
                match v {
                    &select_sql::Select::Query(ref v) => {
                        os.write_string(1, v)?;
                    },
                    &select_sql::Select::AliasedQueries(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SelectSql {
            SelectSql::new()
        }

        fn clear(&mut self) {
            self.select = ::std::option::Option::None;
            self.select = ::std::option::Option::None;
            self.sql_dialect = ::protobuf::EnumOrUnknown::new(SQLDialect::NONE);
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SelectSql {
            static instance: SelectSql = SelectSql {
                sql_dialect: ::protobuf::EnumOrUnknown::from_i32(0),
                select: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SelectSql {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.SelectSql").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SelectSql {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SelectSql {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `SelectSql`
    pub mod select_sql {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:Transform.SelectSql.select)
        pub enum Select {
            // @@protoc_insertion_point(oneof_field:Transform.SelectSql.query)
            Query(::std::string::String),
            // @@protoc_insertion_point(oneof_field:Transform.SelectSql.aliased_queries)
            AliasedQueries(super::AliasedQueries),
        }

        impl ::protobuf::Oneof for Select {
        }

        impl ::protobuf::OneofFull for Select {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::SelectSql as ::protobuf::MessageFull>::descriptor().oneof_by_name("select").unwrap()).clone()
            }
        }

        impl Select {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Select>("select")
            }
        }
    }

    // @@protoc_insertion_point(message:Transform.DPSelectSql)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DPSelectSql {
        // message fields
        // @@protoc_insertion_point(field:Transform.DPSelectSql.sql_dialect)
        pub sql_dialect: ::protobuf::EnumOrUnknown<SQLDialect>,
        // message oneof groups
        pub select: ::std::option::Option<dpselect_sql::Select>,
        // special fields
        // @@protoc_insertion_point(special_field:Transform.DPSelectSql.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DPSelectSql {
        fn default() -> &'a DPSelectSql {
            <DPSelectSql as ::protobuf::Message>::default_instance()
        }
    }

    impl DPSelectSql {
        pub fn new() -> DPSelectSql {
            ::std::default::Default::default()
        }

        // string query = 1;

        pub fn query(&self) -> &str {
            match self.select {
                ::std::option::Option::Some(dpselect_sql::Select::Query(ref v)) => v,
                _ => "",
            }
        }

        pub fn clear_query(&mut self) {
            self.select = ::std::option::Option::None;
        }

        pub fn has_query(&self) -> bool {
            match self.select {
                ::std::option::Option::Some(dpselect_sql::Select::Query(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_query(&mut self, v: ::std::string::String) {
            self.select = ::std::option::Option::Some(dpselect_sql::Select::Query(v))
        }

        // Mutable pointer to the field.
        pub fn mut_query(&mut self) -> &mut ::std::string::String {
            if let ::std::option::Option::Some(dpselect_sql::Select::Query(_)) = self.select {
            } else {
                self.select = ::std::option::Option::Some(dpselect_sql::Select::Query(::std::string::String::new()));
            }
            match self.select {
                ::std::option::Option::Some(dpselect_sql::Select::Query(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_query(&mut self) -> ::std::string::String {
            if self.has_query() {
                match self.select.take() {
                    ::std::option::Option::Some(dpselect_sql::Select::Query(v)) => v,
                    _ => panic!(),
                }
            } else {
                ::std::string::String::new()
            }
        }

        // .Transform.AliasedQueries aliased_queries = 2;

        pub fn aliased_queries(&self) -> &AliasedQueries {
            match self.select {
                ::std::option::Option::Some(dpselect_sql::Select::AliasedQueries(ref v)) => v,
                _ => <AliasedQueries as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_aliased_queries(&mut self) {
            self.select = ::std::option::Option::None;
        }

        pub fn has_aliased_queries(&self) -> bool {
            match self.select {
                ::std::option::Option::Some(dpselect_sql::Select::AliasedQueries(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_aliased_queries(&mut self, v: AliasedQueries) {
            self.select = ::std::option::Option::Some(dpselect_sql::Select::AliasedQueries(v))
        }

        // Mutable pointer to the field.
        pub fn mut_aliased_queries(&mut self) -> &mut AliasedQueries {
            if let ::std::option::Option::Some(dpselect_sql::Select::AliasedQueries(_)) = self.select {
            } else {
                self.select = ::std::option::Option::Some(dpselect_sql::Select::AliasedQueries(AliasedQueries::new()));
            }
            match self.select {
                ::std::option::Option::Some(dpselect_sql::Select::AliasedQueries(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_aliased_queries(&mut self) -> AliasedQueries {
            if self.has_aliased_queries() {
                match self.select.take() {
                    ::std::option::Option::Some(dpselect_sql::Select::AliasedQueries(v)) => v,
                    _ => panic!(),
                }
            } else {
                AliasedQueries::new()
            }
        }

        // .Transform.SQLDialect sql_dialect = 3;

        pub fn sql_dialect(&self) -> SQLDialect {
            self.sql_dialect.enum_value_or_default()
        }

        pub fn clear_sql_dialect(&mut self) {
            self.sql_dialect = ::protobuf::EnumOrUnknown::new(SQLDialect::NONE);
        }

        // Param is passed by value, moved
        pub fn set_sql_dialect(&mut self, v: SQLDialect) {
            self.sql_dialect = ::protobuf::EnumOrUnknown::new(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
                "query",
                DPSelectSql::has_query,
                DPSelectSql::query,
                DPSelectSql::set_query,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, AliasedQueries>(
                "aliased_queries",
                DPSelectSql::has_aliased_queries,
                DPSelectSql::aliased_queries,
                DPSelectSql::mut_aliased_queries,
                DPSelectSql::set_aliased_queries,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "sql_dialect",
                |m: &DPSelectSql| { &m.sql_dialect },
                |m: &mut DPSelectSql| { &mut m.sql_dialect },
            ));
            oneofs.push(dpselect_sql::Select::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DPSelectSql>(
                "Transform.DPSelectSql",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DPSelectSql {
        const NAME: &'static str = "DPSelectSql";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.select = ::std::option::Option::Some(dpselect_sql::Select::Query(is.read_string()?));
                    },
                    18 => {
                        self.select = ::std::option::Option::Some(dpselect_sql::Select::AliasedQueries(is.read_message()?));
                    },
                    24 => {
                        self.sql_dialect = is.read_enum_or_unknown()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.sql_dialect != ::protobuf::EnumOrUnknown::new(SQLDialect::NONE) {
                my_size += ::protobuf::rt::int32_size(3, self.sql_dialect.value());
            }
            if let ::std::option::Option::Some(ref v) = self.select {
                match v {
                    &dpselect_sql::Select::Query(ref v) => {
                        my_size += ::protobuf::rt::string_size(1, &v);
                    },
                    &dpselect_sql::Select::AliasedQueries(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.sql_dialect != ::protobuf::EnumOrUnknown::new(SQLDialect::NONE) {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.sql_dialect))?;
            }
            if let ::std::option::Option::Some(ref v) = self.select {
                match v {
                    &dpselect_sql::Select::Query(ref v) => {
                        os.write_string(1, v)?;
                    },
                    &dpselect_sql::Select::AliasedQueries(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DPSelectSql {
            DPSelectSql::new()
        }

        fn clear(&mut self) {
            self.select = ::std::option::Option::None;
            self.select = ::std::option::Option::None;
            self.sql_dialect = ::protobuf::EnumOrUnknown::new(SQLDialect::NONE);
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DPSelectSql {
            static instance: DPSelectSql = DPSelectSql {
                sql_dialect: ::protobuf::EnumOrUnknown::from_i32(0),
                select: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DPSelectSql {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.DPSelectSql").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DPSelectSql {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DPSelectSql {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `DPSelectSql`
    pub mod dpselect_sql {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:Transform.DPSelectSql.select)
        pub enum Select {
            // @@protoc_insertion_point(oneof_field:Transform.DPSelectSql.query)
            Query(::std::string::String),
            // @@protoc_insertion_point(oneof_field:Transform.DPSelectSql.aliased_queries)
            AliasedQueries(super::AliasedQueries),
        }

        impl ::protobuf::Oneof for Select {
        }

        impl ::protobuf::OneofFull for Select {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::DPSelectSql as ::protobuf::MessageFull>::descriptor().oneof_by_name("select").unwrap()).clone()
            }
        }

        impl Select {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Select>("select")
            }
        }
    }

    // @@protoc_insertion_point(message:Transform.AliasedQueries)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AliasedQueries {
        // message fields
        // @@protoc_insertion_point(field:Transform.AliasedQueries.aliased_query)
        pub aliased_query: ::std::vec::Vec<AliasedQuery>,
        // special fields
        // @@protoc_insertion_point(special_field:Transform.AliasedQueries.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AliasedQueries {
        fn default() -> &'a AliasedQueries {
            <AliasedQueries as ::protobuf::Message>::default_instance()
        }
    }

    impl AliasedQueries {
        pub fn new() -> AliasedQueries {
            ::std::default::Default::default()
        }

        // repeated .Transform.AliasedQuery aliased_query = 1;

        pub fn aliased_query(&self) -> &[AliasedQuery] {
            &self.aliased_query
        }

        pub fn clear_aliased_query(&mut self) {
            self.aliased_query.clear();
        }

        // Param is passed by value, moved
        pub fn set_aliased_query(&mut self, v: ::std::vec::Vec<AliasedQuery>) {
            self.aliased_query = v;
        }

        // Mutable pointer to the field.
        pub fn mut_aliased_query(&mut self) -> &mut ::std::vec::Vec<AliasedQuery> {
            &mut self.aliased_query
        }

        // Take field
        pub fn take_aliased_query(&mut self) -> ::std::vec::Vec<AliasedQuery> {
            ::std::mem::replace(&mut self.aliased_query, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "aliased_query",
                |m: &AliasedQueries| { &m.aliased_query },
                |m: &mut AliasedQueries| { &mut m.aliased_query },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AliasedQueries>(
                "Transform.AliasedQueries",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AliasedQueries {
        const NAME: &'static str = "AliasedQueries";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.aliased_query.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.aliased_query {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.aliased_query {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AliasedQueries {
            AliasedQueries::new()
        }

        fn clear(&mut self) {
            self.aliased_query.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AliasedQueries {
            static instance: AliasedQueries = AliasedQueries {
                aliased_query: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AliasedQueries {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.AliasedQueries").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AliasedQueries {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AliasedQueries {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.AliasedQuery)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AliasedQuery {
        // message fields
        // @@protoc_insertion_point(field:Transform.AliasedQuery.path)
        pub path: ::protobuf::MessageField<super::super::path::Path>,
        // @@protoc_insertion_point(field:Transform.AliasedQuery.query)
        pub query: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:Transform.AliasedQuery.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AliasedQuery {
        fn default() -> &'a AliasedQuery {
            <AliasedQuery as ::protobuf::Message>::default_instance()
        }
    }

    impl AliasedQuery {
        pub fn new() -> AliasedQuery {
            ::std::default::Default::default()
        }

        // .sarus_data_spec.Path path = 1;

        pub fn path(&self) -> &super::super::path::Path {
            self.path.as_ref().unwrap_or_else(|| <super::super::path::Path as ::protobuf::Message>::default_instance())
        }

        pub fn clear_path(&mut self) {
            self.path.clear();
        }

        pub fn has_path(&self) -> bool {
            self.path.is_some()
        }

        // Param is passed by value, moved
        pub fn set_path(&mut self, v: super::super::path::Path) {
            self.path = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_path(&mut self) -> &mut super::super::path::Path {
            self.path.mut_or_insert_default()
        }

        // Take field
        pub fn take_path(&mut self) -> super::super::path::Path {
            self.path.take().unwrap_or_else(|| super::super::path::Path::new())
        }

        // string query = 2;

        pub fn query(&self) -> &str {
            &self.query
        }

        pub fn clear_query(&mut self) {
            self.query.clear();
        }

        // Param is passed by value, moved
        pub fn set_query(&mut self, v: ::std::string::String) {
            self.query = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_query(&mut self) -> &mut ::std::string::String {
            &mut self.query
        }

        // Take field
        pub fn take_query(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.query, ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::path::Path>(
                "path",
                |m: &AliasedQuery| { &m.path },
                |m: &mut AliasedQuery| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "query",
                |m: &AliasedQuery| { &m.query },
                |m: &mut AliasedQuery| { &mut m.query },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AliasedQuery>(
                "Transform.AliasedQuery",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AliasedQuery {
        const NAME: &'static str = "AliasedQuery";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.path)?;
                    },
                    18 => {
                        self.query = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.path.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.query.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.query);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.path.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if !self.query.is_empty() {
                os.write_string(2, &self.query)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AliasedQuery {
            AliasedQuery::new()
        }

        fn clear(&mut self) {
            self.path.clear();
            self.query.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AliasedQuery {
            static instance: AliasedQuery = AliasedQuery {
                path: ::protobuf::MessageField::none(),
                query: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AliasedQuery {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.AliasedQuery").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AliasedQuery {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AliasedQuery {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.Extract)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Extract {
        // message fields
        // @@protoc_insertion_point(field:Transform.Extract.size)
        pub size: i32,
        // special fields
        // @@protoc_insertion_point(special_field:Transform.Extract.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Extract {
        fn default() -> &'a Extract {
            <Extract as ::protobuf::Message>::default_instance()
        }
    }

    impl Extract {
        pub fn new() -> Extract {
            ::std::default::Default::default()
        }

        // int32 size = 1;

        pub fn size(&self) -> i32 {
            self.size
        }

        pub fn clear_size(&mut self) {
            self.size = 0;
        }

        // Param is passed by value, moved
        pub fn set_size(&mut self, v: i32) {
            self.size = v;
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "size",
                |m: &Extract| { &m.size },
                |m: &mut Extract| { &mut m.size },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Extract>(
                "Transform.Extract",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Extract {
        const NAME: &'static str = "Extract";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.size = is.read_int32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.size != 0 {
                my_size += ::protobuf::rt::int32_size(1, self.size);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.size != 0 {
                os.write_int32(1, self.size)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Extract {
            Extract::new()
        }

        fn clear(&mut self) {
            self.size = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Extract {
            static instance: Extract = Extract {
                size: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Extract {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.Extract").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Extract {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Extract {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:Transform.ValidatedUserType)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ValidatedUserType {
        // special fields
        // @@protoc_insertion_point(special_field:Transform.ValidatedUserType.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ValidatedUserType {
        fn default() -> &'a ValidatedUserType {
            <ValidatedUserType as ::protobuf::Message>::default_instance()
        }
    }

    impl ValidatedUserType {
        pub fn new() -> ValidatedUserType {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatedUserType>(
                "Transform.ValidatedUserType",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ValidatedUserType {
        const NAME: &'static str = "ValidatedUserType";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ValidatedUserType {
            ValidatedUserType::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ValidatedUserType {
            static instance: ValidatedUserType = ValidatedUserType {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ValidatedUserType {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Transform.ValidatedUserType").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ValidatedUserType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ValidatedUserType {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:Transform.SQLDialect)
    pub enum SQLDialect {
        // @@protoc_insertion_point(enum_value:Transform.SQLDialect.NONE)
        NONE = 0,
        // @@protoc_insertion_point(enum_value:Transform.SQLDialect.POSTGRES)
        POSTGRES = 1,
        // @@protoc_insertion_point(enum_value:Transform.SQLDialect.SQL_SERVER)
        SQL_SERVER = 2,
        // @@protoc_insertion_point(enum_value:Transform.SQLDialect.MY_SQL)
        MY_SQL = 3,
        // @@protoc_insertion_point(enum_value:Transform.SQLDialect.SQLLITE)
        SQLLITE = 4,
        // @@protoc_insertion_point(enum_value:Transform.SQLDialect.ORACLE)
        ORACLE = 5,
        // @@protoc_insertion_point(enum_value:Transform.SQLDialect.BIG_QUERY)
        BIG_QUERY = 6,
        // @@protoc_insertion_point(enum_value:Transform.SQLDialect.REDSHIFT)
        REDSHIFT = 7,
        // @@protoc_insertion_point(enum_value:Transform.SQLDialect.HIVE)
        HIVE = 8,
    }

    impl ::protobuf::Enum for SQLDialect {
        const NAME: &'static str = "SQLDialect";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<SQLDialect> {
            match value {
                0 => ::std::option::Option::Some(SQLDialect::NONE),
                1 => ::std::option::Option::Some(SQLDialect::POSTGRES),
                2 => ::std::option::Option::Some(SQLDialect::SQL_SERVER),
                3 => ::std::option::Option::Some(SQLDialect::MY_SQL),
                4 => ::std::option::Option::Some(SQLDialect::SQLLITE),
                5 => ::std::option::Option::Some(SQLDialect::ORACLE),
                6 => ::std::option::Option::Some(SQLDialect::BIG_QUERY),
                7 => ::std::option::Option::Some(SQLDialect::REDSHIFT),
                8 => ::std::option::Option::Some(SQLDialect::HIVE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<SQLDialect> {
            match str {
                "NONE" => ::std::option::Option::Some(SQLDialect::NONE),
                "POSTGRES" => ::std::option::Option::Some(SQLDialect::POSTGRES),
                "SQL_SERVER" => ::std::option::Option::Some(SQLDialect::SQL_SERVER),
                "MY_SQL" => ::std::option::Option::Some(SQLDialect::MY_SQL),
                "SQLLITE" => ::std::option::Option::Some(SQLDialect::SQLLITE),
                "ORACLE" => ::std::option::Option::Some(SQLDialect::ORACLE),
                "BIG_QUERY" => ::std::option::Option::Some(SQLDialect::BIG_QUERY),
                "REDSHIFT" => ::std::option::Option::Some(SQLDialect::REDSHIFT),
                "HIVE" => ::std::option::Option::Some(SQLDialect::HIVE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [SQLDialect] = &[
            SQLDialect::NONE,
            SQLDialect::POSTGRES,
            SQLDialect::SQL_SERVER,
            SQLDialect::MY_SQL,
            SQLDialect::SQLLITE,
            SQLDialect::ORACLE,
            SQLDialect::BIG_QUERY,
            SQLDialect::REDSHIFT,
            SQLDialect::HIVE,
        ];
    }

    impl ::protobuf::EnumFull for SQLDialect {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Transform.SQLDialect").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for SQLDialect {
        fn default() -> Self {
            SQLDialect::NONE
        }
    }

    impl SQLDialect {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SQLDialect>("Transform.SQLDialect")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n(sarus_data_spec/protobuf/transform.proto\x1a#sarus_data_spec/protobuf\
    /type.proto\x1a#sarus_data_spec/protobuf/path.proto\x1a%sarus_data_spec/\
    protobuf/scalar.proto\"\xff(\n\tTransform\x12\x12\n\x04uuid\x18\x01\x20\
    \x01(\tR\x04uuid\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x10\n\
    \x03doc\x18\x03\x20\x01(\tR\x03doc\x12#\n\x04spec\x18\x04\x20\x01(\x0b2\
    \x0f.Transform.SpecR\x04spec\x12:\n\nproperties\x18\x05\x20\x03(\x0b2\
    \x1a.Transform.PropertiesEntryR\nproperties\x12\x1e\n\ninversible\x18\
    \x06\x20\x01(\x08R\ninversible\x12+\n\x11schema_preserving\x18\x07\x20\
    \x01(\x08R\x10schemaPreserving\x1a=\n\x0fPropertiesEntry\x12\x10\n\x03ke\
    y\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05v\
    alue:\x028\x01\x1a\x81\x0f\n\x04Spec\x121\n\x08identity\x18\x01\x20\x01(\
    \x0b2\x13.Transform.IdentityH\0R\x08identity\x121\n\x08variable\x18\x02\
    \x20\x01(\x0b2\x13.Transform.VariableH\0R\x08variable\x121\n\x08composed\
    \x18\x03\x20\x01(\x0b2\x13.Transform.ComposedH\0R\x08composed\x12.\n\x07\
    project\x18\x04\x20\x01(\x0b2\x12.Transform.ProjectH\0R\x07project\x12+\
    \n\x06filter\x18\x05\x20\x01(\x0b2\x11.Transform.FilterH\0R\x06filter\
    \x12.\n\x07shuffle\x18\x06\x20\x01(\x0b2\x12.Transform.ShuffleH\0R\x07sh\
    uffle\x12%\n\x04join\x18\x07\x20\x01(\x0b2\x0f.Transform.JoinH\0R\x04joi\
    n\x12%\n\x04cast\x18\x08\x20\x01(\x0b2\x0f.Transform.CastH\0R\x04cast\
    \x12+\n\x06sample\x18\t\x20\x01(\x0b2\x11.Transform.SampleH\0R\x06sample\
    \x12>\n\ruser_settings\x18\n\x20\x01(\x0b2\x17.Transform.UserSettingsH\0\
    R\x0cuserSettings\x12=\n\x0fprotect_dataset\x18\x0b\x20\x01(\x0b2\x12.Tr\
    ansform.ProtectH\0R\x0eprotectDataset\x121\n\x08external\x18\x0c\x20\x01\
    (\x0b2\x13.Transform.ExternalH\0R\x08external\x124\n\tsynthetic\x18\r\
    \x20\x01(\x0b2\x14.Transform.SyntheticH\0R\tsynthetic\x124\n\ttranscode\
    \x18\x0e\x20\x01(\x0b2\x14.Transform.TranscodeH\0R\ttranscode\x12J\n\x11\
    inverse_transcode\x18\x0f\x20\x01(\x0b2\x1b.Transform.InverseTranscodeH\
    \0R\x10inverseTranscode\x12/\n\x08get_item\x18\x10\x20\x01(\x0b2\x12.Tra\
    nsform.GetItemH\0R\x07getItem\x12D\n\x0fprotected_paths\x18\x11\x20\x01(\
    \x0b2\x19.Transform.ProtectedPathsH\0R\x0eprotectedPaths\x12Z\n\x17autom\
    atic_user_settings\x18\x12\x20\x01(\x0b2\x20.Transform.AutomaticUserSett\
    ingsH\0R\x15automaticUserSettings\x12;\n\x0cpublic_paths\x18\x13\x20\x01\
    (\x0b2\x16.Transform.PublicPathsH\0R\x0bpublicPaths\x12>\n\rassign_budge\
    t\x18\x14\x20\x01(\x0b2\x17.Transform.AssignBudgetH\0R\x0cassignBudget\
    \x12G\n\x10automatic_budget\x18\x15\x20\x01(\x0b2\x1a.Transform.Automati\
    cBudgetH\0R\x0fautomaticBudget\x12H\n\x10attribute_budget\x18\x16\x20\
    \x01(\x0b2\x1b.Transform.AttributesBudgetH\0R\x0fattributeBudget\x122\n\
    \tsd_budget\x18\x17\x20\x01(\x0b2\x13.Transform.SDBudgetH\0R\x08sdBudget\
    \x128\n\x0bderive_seed\x18\x18\x20\x01(\x0b2\x15.Transform.DeriveSeedH\0\
    R\nderiveSeed\x126\n\x0bgroup_by_pe\x18\x19\x20\x01(\x0b2\x14.Transform.\
    GroupByPEH\0R\tgroupByPe\x12D\n\x0fsampling_ratios\x18\x1a\x20\x01(\x0b2\
    \x19.Transform.SamplingRatiosH\0R\x0esamplingRatios\x125\n\nselect_sql\
    \x18\x1b\x20\x01(\x0b2\x14.Transform.SelectSqlH\0R\tselectSql\x12.\n\x07\
    extract\x18\x1c\x20\x01(\x0b2\x12.Transform.ExtractH\0R\x07extract\x12J\
    \n\x11relationship_spec\x18\x1d\x20\x01(\x0b2\x1b.Transform.Relationship\
    SpecH\0R\x10relationshipSpec\x12V\n\x15differentiated_sample\x18\x1e\x20\
    \x01(\x0b2\x1f.Transform.DifferentiatedSampleH\0R\x14differentiatedSampl\
    e\x12N\n\x13validated_user_type\x18\x1f\x20\x01(\x0b2\x1c.Transform.Vali\
    datedUserTypeH\0R\x11validatedUserType\x12<\n\rdp_select_sql\x18\x20\x20\
    \x01(\x0b2\x16.Transform.DPSelectSqlH\0R\x0bdpSelectSqlB\x06\n\x04spec\
    \x1a\xd4\x07\n\x08External\x12\x1c\n\targuments\x18\x01\x20\x01(\x0cR\ta\
    rguments\x12'\n\x0fnamed_arguments\x18\x02\x20\x01(\x0cR\x0enamedArgumen\
    ts\x12E\n\rop_identifier\x18\x03\x20\x01(\x0b2\x20.Transform.External.Op\
    IdentifierR\x0copIdentifier\x1a\x9f\x04\n\x0cOpIdentifier\x12+\n\x03std\
    \x18\x01\x20\x01(\x0b2\x17.Transform.External.StdH\0R\x03std\x124\n\x06p\
    andas\x18\x02\x20\x01(\x0b2\x1a.Transform.External.PandasH\0R\x06pandas\
    \x121\n\x05numpy\x18\x03\x20\x01(\x0b2\x19.Transform.External.NumpyH\0R\
    \x05numpy\x12@\n\ntensorflow\x18\x04\x20\x01(\x0b2\x1e.Transform.Externa\
    l.TensorflowH\0R\ntensorflow\x127\n\x07sklearn\x18\x05\x20\x01(\x0b2\x1b\
    .Transform.External.SklearnH\0R\x07sklearn\x12P\n\x10pandas_profiling\
    \x18\x06\x20\x01(\x0b2#.Transform.External.PandasProfilingH\0R\x0fpandas\
    Profiling\x127\n\x07xgboost\x18\x07\x20\x01(\x0b2\x1b.Transform.External\
    .XGBoostH\0R\x07xgboost\x121\n\x05skopt\x18\x08\x20\x01(\x0b2\x19.Transf\
    orm.External.SkoptH\0R\x05skopt\x12:\n\x08imblearn\x18\t\x20\x01(\x0b2\
    \x1c.Transform.External.ImblearnH\0R\x08imblearnB\x04\n\x02op\x1a\x19\n\
    \x03Std\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x1a\x1c\n\x06Panda\
    s\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x1a\x1b\n\x05Numpy\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x1a\x20\n\nTensorflow\x12\x12\
    \n\x04name\x18\x01\x20\x01(\tR\x04name\x1a\x1d\n\x07Sklearn\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x1a%\n\x0fPandasProfiling\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x1a\x1d\n\x07XGBoost\x12\x12\n\x04n\
    ame\x18\x01\x20\x01(\tR\x04name\x1a\x1b\n\x05Skopt\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x1a\x1e\n\x08Imblearn\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\x1a\n\n\x08Identity\x1a:\n\x08Variable\x12\x1a\n\
    \x08position\x18\x01\x20\x01(\x05R\x08position\x12\x12\n\x04name\x18\x02\
    \x20\x01(\tR\x04name\x1a\xdb\x01\n\x08Composed\x12\x1c\n\ttransform\x18\
    \x01\x20\x01(\tR\ttransform\x12\x1c\n\targuments\x18\x02\x20\x03(\tR\tar\
    guments\x12P\n\x0fnamed_arguments\x18\x03\x20\x03(\x0b2'.Transform.Compo\
    sed.NamedArgumentsEntryR\x0enamedArguments\x1aA\n\x13NamedArgumentsEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value:\x028\x01\x1a@\n\x07Project\x125\n\nprojection\x18\
    \x01\x20\x01(\x0b2\x15.sarus_data_spec.TypeR\nprojection\x1a7\n\x06Filte\
    r\x12-\n\x06filter\x18\x01\x20\x01(\x0b2\x15.sarus_data_spec.TypeR\x06fi\
    lter\x1a\t\n\x07Shuffle\x1a-\n\x04Join\x12%\n\x02on\x18\x01\x20\x01(\x0b\
    2\x15.sarus_data_spec.TypeR\x02on\x1a1\n\x04Cast\x12)\n\x04type\x18\x01\
    \x20\x01(\x0b2\x15.sarus_data_spec.TypeR\x04type\x1aw\n\x06Sample\x12\
    \x1c\n\x08fraction\x18\x01\x20\x01(\x01H\0R\x08fraction\x12\x14\n\x04siz\
    e\x18\x02\x20\x01(\x03H\0R\x04size\x12+\n\x04seed\x18\x03\x20\x01(\x0b2\
    \x17.sarus_data_spec.ScalarR\x04seedB\x0c\n\nproportion\x1a\x82\x01\n\
    \x0fSchemaInference\x12F\n\x0bcast_policy\x18\x01\x20\x01(\x0e2%.Transfo\
    rm.SchemaInference.CastPolicyR\ncastPolicy\"'\n\nCastPolicy\x12\x08\n\
    \x04NONE\x10\0\x12\x0f\n\x0bMOST_LIKELY\x10\x01\x1a\x1b\n\x07GroupBy\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x1a\x0b\n\tSynthetic\x1a\x0e\n\
    \x0cUserSettings\x1a>\n\x15AutomaticUserSettings\x12%\n\x0emax_categorie\
    s\x18\x01\x20\x01(\x03R\rmaxCategories\x1a\t\n\x07Protect\x1a\x0b\n\tTra\
    nscode\x1a\x12\n\x10InverseTranscode\x1a\x85\x01\n\x14DifferentiatedSamp\
    le\x12\x1c\n\x08fraction\x18\x01\x20\x01(\x01H\0R\x08fraction\x12\x14\n\
    \x04size\x18\x02\x20\x01(\x03H\0R\x04size\x12+\n\x04seed\x18\x03\x20\x01\
    (\x0b2\x17.sarus_data_spec.ScalarR\x04seedB\x0c\n\nproportion\x1a\x10\n\
    \x0eProtectedPaths\x1a\r\n\x0bPublicPaths\x1a4\n\x07GetItem\x12)\n\x04pa\
    th\x18\x01\x20\x01(\x0b2\x15.sarus_data_spec.PathR\x04path\x1a\x0e\n\x0c\
    AssignBudget\x1a\x11\n\x0fAutomaticBudget\x1a\x12\n\x10AttributesBudget\
    \x1a\n\n\x08SDBudget\x1a3\n\nDeriveSeed\x12%\n\x0erandom_integer\x18\x01\
    \x20\x01(\x03R\rrandomInteger\x1a\x0b\n\tGroupByPE\x1a\x10\n\x0eSampling\
    Ratios\x1a\x12\n\x10RelationshipSpec\x1a\xab\x01\n\tSelectSql\x12\x16\n\
    \x05query\x18\x01\x20\x01(\tH\0R\x05query\x12D\n\x0faliased_queries\x18\
    \x02\x20\x01(\x0b2\x19.Transform.AliasedQueriesH\0R\x0ealiasedQueries\
    \x126\n\x0bsql_dialect\x18\x03\x20\x01(\x0e2\x15.Transform.SQLDialectR\n\
    sqlDialectB\x08\n\x06select\x1a\xad\x01\n\x0bDPSelectSql\x12\x16\n\x05qu\
    ery\x18\x01\x20\x01(\tH\0R\x05query\x12D\n\x0faliased_queries\x18\x02\
    \x20\x01(\x0b2\x19.Transform.AliasedQueriesH\0R\x0ealiasedQueries\x126\n\
    \x0bsql_dialect\x18\x03\x20\x01(\x0e2\x15.Transform.SQLDialectR\nsqlDial\
    ectB\x08\n\x06select\x1aN\n\x0eAliasedQueries\x12<\n\raliased_query\x18\
    \x01\x20\x03(\x0b2\x17.Transform.AliasedQueryR\x0caliasedQuery\x1aO\n\
    \x0cAliasedQuery\x12)\n\x04path\x18\x01\x20\x01(\x0b2\x15.sarus_data_spe\
    c.PathR\x04path\x12\x14\n\x05query\x18\x02\x20\x01(\tR\x05query\x1a\x1d\
    \n\x07Extract\x12\x12\n\x04size\x18\x01\x20\x01(\x05R\x04size\x1a\x13\n\
    \x11ValidatedUserType\"\x80\x01\n\nSQLDialect\x12\x08\n\x04NONE\x10\0\
    \x12\x0c\n\x08POSTGRES\x10\x01\x12\x0e\n\nSQL_SERVER\x10\x02\x12\n\n\x06\
    MY_SQL\x10\x03\x12\x0b\n\x07SQLLITE\x10\x04\x12\n\n\x06ORACLE\x10\x05\
    \x12\r\n\tBIG_QUERY\x10\x06\x12\x0c\n\x08REDSHIFT\x10\x07\x12\x08\n\x04H\
    IVE\x10\x08b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::type_::file_descriptor().clone());
            deps.push(super::path::file_descriptor().clone());
            deps.push(super::scalar::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(48);
            messages.push(Transform::generated_message_descriptor_data());
            messages.push(transform::Spec::generated_message_descriptor_data());
            messages.push(transform::External::generated_message_descriptor_data());
            messages.push(transform::Identity::generated_message_descriptor_data());
            messages.push(transform::Variable::generated_message_descriptor_data());
            messages.push(transform::Composed::generated_message_descriptor_data());
            messages.push(transform::Project::generated_message_descriptor_data());
            messages.push(transform::Filter::generated_message_descriptor_data());
            messages.push(transform::Shuffle::generated_message_descriptor_data());
            messages.push(transform::Join::generated_message_descriptor_data());
            messages.push(transform::Cast::generated_message_descriptor_data());
            messages.push(transform::Sample::generated_message_descriptor_data());
            messages.push(transform::SchemaInference::generated_message_descriptor_data());
            messages.push(transform::GroupBy::generated_message_descriptor_data());
            messages.push(transform::Synthetic::generated_message_descriptor_data());
            messages.push(transform::UserSettings::generated_message_descriptor_data());
            messages.push(transform::AutomaticUserSettings::generated_message_descriptor_data());
            messages.push(transform::Protect::generated_message_descriptor_data());
            messages.push(transform::Transcode::generated_message_descriptor_data());
            messages.push(transform::InverseTranscode::generated_message_descriptor_data());
            messages.push(transform::DifferentiatedSample::generated_message_descriptor_data());
            messages.push(transform::ProtectedPaths::generated_message_descriptor_data());
            messages.push(transform::PublicPaths::generated_message_descriptor_data());
            messages.push(transform::GetItem::generated_message_descriptor_data());
            messages.push(transform::AssignBudget::generated_message_descriptor_data());
            messages.push(transform::AutomaticBudget::generated_message_descriptor_data());
            messages.push(transform::AttributesBudget::generated_message_descriptor_data());
            messages.push(transform::SDBudget::generated_message_descriptor_data());
            messages.push(transform::DeriveSeed::generated_message_descriptor_data());
            messages.push(transform::GroupByPE::generated_message_descriptor_data());
            messages.push(transform::SamplingRatios::generated_message_descriptor_data());
            messages.push(transform::RelationshipSpec::generated_message_descriptor_data());
            messages.push(transform::SelectSql::generated_message_descriptor_data());
            messages.push(transform::DPSelectSql::generated_message_descriptor_data());
            messages.push(transform::AliasedQueries::generated_message_descriptor_data());
            messages.push(transform::AliasedQuery::generated_message_descriptor_data());
            messages.push(transform::Extract::generated_message_descriptor_data());
            messages.push(transform::ValidatedUserType::generated_message_descriptor_data());
            messages.push(transform::external::OpIdentifier::generated_message_descriptor_data());
            messages.push(transform::external::Std::generated_message_descriptor_data());
            messages.push(transform::external::Pandas::generated_message_descriptor_data());
            messages.push(transform::external::Numpy::generated_message_descriptor_data());
            messages.push(transform::external::Tensorflow::generated_message_descriptor_data());
            messages.push(transform::external::Sklearn::generated_message_descriptor_data());
            messages.push(transform::external::PandasProfiling::generated_message_descriptor_data());
            messages.push(transform::external::XGBoost::generated_message_descriptor_data());
            messages.push(transform::external::Skopt::generated_message_descriptor_data());
            messages.push(transform::external::Imblearn::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(transform::SQLDialect::generated_enum_descriptor_data());
            enums.push(transform::schema_inference::CastPolicy::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
