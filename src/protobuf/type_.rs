// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `sarus_data_spec/protobuf/type.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:sarus_data_spec.Type)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Type {
    // message fields
    // @@protoc_insertion_point(field:sarus_data_spec.Type.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:sarus_data_spec.Type.properties)
    pub properties: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // message oneof groups
    pub type_: ::std::option::Option<type_::Type>,
    // special fields
    // @@protoc_insertion_point(special_field:sarus_data_spec.Type.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Type {
    fn default() -> &'a Type {
        <Type as ::protobuf::Message>::default_instance()
    }
}

impl Type {
    pub fn new() -> Type {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn name(&self) -> &str {
        &self.name
    }

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .sarus_data_spec.Type.Null null = 3;

    pub fn null(&self) -> &type_::Null {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Null(ref v)) => v,
            _ => <type_::Null as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_null(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_null(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Null(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_null(&mut self, v: type_::Null) {
        self.type_ = ::std::option::Option::Some(type_::Type::Null(v))
    }

    // Mutable pointer to the field.
    pub fn mut_null(&mut self) -> &mut type_::Null {
        if let ::std::option::Option::Some(type_::Type::Null(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(type_::Type::Null(type_::Null::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Null(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_null(&mut self) -> type_::Null {
        if self.has_null() {
            match self.type_.take() {
                ::std::option::Option::Some(type_::Type::Null(v)) => v,
                _ => panic!(),
            }
        } else {
            type_::Null::new()
        }
    }

    // .sarus_data_spec.Type.Unit unit = 4;

    pub fn unit(&self) -> &type_::Unit {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Unit(ref v)) => v,
            _ => <type_::Unit as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_unit(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_unit(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Unit(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unit(&mut self, v: type_::Unit) {
        self.type_ = ::std::option::Option::Some(type_::Type::Unit(v))
    }

    // Mutable pointer to the field.
    pub fn mut_unit(&mut self) -> &mut type_::Unit {
        if let ::std::option::Option::Some(type_::Type::Unit(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(type_::Type::Unit(type_::Unit::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Unit(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_unit(&mut self) -> type_::Unit {
        if self.has_unit() {
            match self.type_.take() {
                ::std::option::Option::Some(type_::Type::Unit(v)) => v,
                _ => panic!(),
            }
        } else {
            type_::Unit::new()
        }
    }

    // .sarus_data_spec.Type.Boolean boolean = 5;

    pub fn boolean(&self) -> &type_::Boolean {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Boolean(ref v)) => v,
            _ => <type_::Boolean as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_boolean(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_boolean(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Boolean(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_boolean(&mut self, v: type_::Boolean) {
        self.type_ = ::std::option::Option::Some(type_::Type::Boolean(v))
    }

    // Mutable pointer to the field.
    pub fn mut_boolean(&mut self) -> &mut type_::Boolean {
        if let ::std::option::Option::Some(type_::Type::Boolean(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(type_::Type::Boolean(type_::Boolean::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Boolean(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_boolean(&mut self) -> type_::Boolean {
        if self.has_boolean() {
            match self.type_.take() {
                ::std::option::Option::Some(type_::Type::Boolean(v)) => v,
                _ => panic!(),
            }
        } else {
            type_::Boolean::new()
        }
    }

    // .sarus_data_spec.Type.Integer integer = 6;

    pub fn integer(&self) -> &type_::Integer {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Integer(ref v)) => v,
            _ => <type_::Integer as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_integer(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_integer(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Integer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_integer(&mut self, v: type_::Integer) {
        self.type_ = ::std::option::Option::Some(type_::Type::Integer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_integer(&mut self) -> &mut type_::Integer {
        if let ::std::option::Option::Some(type_::Type::Integer(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(type_::Type::Integer(type_::Integer::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Integer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_integer(&mut self) -> type_::Integer {
        if self.has_integer() {
            match self.type_.take() {
                ::std::option::Option::Some(type_::Type::Integer(v)) => v,
                _ => panic!(),
            }
        } else {
            type_::Integer::new()
        }
    }

    // .sarus_data_spec.Type.Enum enum = 7;

    pub fn enum_(&self) -> &type_::Enum {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Enum(ref v)) => v,
            _ => <type_::Enum as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_enum_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_enum(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Enum(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_enum(&mut self, v: type_::Enum) {
        self.type_ = ::std::option::Option::Some(type_::Type::Enum(v))
    }

    // Mutable pointer to the field.
    pub fn mut_enum(&mut self) -> &mut type_::Enum {
        if let ::std::option::Option::Some(type_::Type::Enum(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(type_::Type::Enum(type_::Enum::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Enum(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_enum_(&mut self) -> type_::Enum {
        if self.has_enum() {
            match self.type_.take() {
                ::std::option::Option::Some(type_::Type::Enum(v)) => v,
                _ => panic!(),
            }
        } else {
            type_::Enum::new()
        }
    }

    // .sarus_data_spec.Type.Float float = 8;

    pub fn float(&self) -> &type_::Float {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Float(ref v)) => v,
            _ => <type_::Float as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_float(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_float(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Float(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_float(&mut self, v: type_::Float) {
        self.type_ = ::std::option::Option::Some(type_::Type::Float(v))
    }

    // Mutable pointer to the field.
    pub fn mut_float(&mut self) -> &mut type_::Float {
        if let ::std::option::Option::Some(type_::Type::Float(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(type_::Type::Float(type_::Float::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Float(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_float(&mut self) -> type_::Float {
        if self.has_float() {
            match self.type_.take() {
                ::std::option::Option::Some(type_::Type::Float(v)) => v,
                _ => panic!(),
            }
        } else {
            type_::Float::new()
        }
    }

    // .sarus_data_spec.Type.Text text = 9;

    pub fn text(&self) -> &type_::Text {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Text(ref v)) => v,
            _ => <type_::Text as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_text(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Text(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: type_::Text) {
        self.type_ = ::std::option::Option::Some(type_::Type::Text(v))
    }

    // Mutable pointer to the field.
    pub fn mut_text(&mut self) -> &mut type_::Text {
        if let ::std::option::Option::Some(type_::Type::Text(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(type_::Type::Text(type_::Text::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Text(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_text(&mut self) -> type_::Text {
        if self.has_text() {
            match self.type_.take() {
                ::std::option::Option::Some(type_::Type::Text(v)) => v,
                _ => panic!(),
            }
        } else {
            type_::Text::new()
        }
    }

    // .sarus_data_spec.Type.Bytes bytes = 10;

    pub fn bytes(&self) -> &type_::Bytes {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Bytes(ref v)) => v,
            _ => <type_::Bytes as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_bytes(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_bytes(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Bytes(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: type_::Bytes) {
        self.type_ = ::std::option::Option::Some(type_::Type::Bytes(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bytes(&mut self) -> &mut type_::Bytes {
        if let ::std::option::Option::Some(type_::Type::Bytes(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(type_::Type::Bytes(type_::Bytes::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Bytes(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bytes(&mut self) -> type_::Bytes {
        if self.has_bytes() {
            match self.type_.take() {
                ::std::option::Option::Some(type_::Type::Bytes(v)) => v,
                _ => panic!(),
            }
        } else {
            type_::Bytes::new()
        }
    }

    // .sarus_data_spec.Type.Struct struct = 11;

    pub fn struct_(&self) -> &type_::Struct {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Struct(ref v)) => v,
            _ => <type_::Struct as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_struct_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_struct(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Struct(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_struct(&mut self, v: type_::Struct) {
        self.type_ = ::std::option::Option::Some(type_::Type::Struct(v))
    }

    // Mutable pointer to the field.
    pub fn mut_struct(&mut self) -> &mut type_::Struct {
        if let ::std::option::Option::Some(type_::Type::Struct(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(type_::Type::Struct(type_::Struct::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Struct(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_struct_(&mut self) -> type_::Struct {
        if self.has_struct() {
            match self.type_.take() {
                ::std::option::Option::Some(type_::Type::Struct(v)) => v,
                _ => panic!(),
            }
        } else {
            type_::Struct::new()
        }
    }

    // .sarus_data_spec.Type.Union union = 12;

    pub fn union(&self) -> &type_::Union {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Union(ref v)) => v,
            _ => <type_::Union as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_union(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_union(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Union(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_union(&mut self, v: type_::Union) {
        self.type_ = ::std::option::Option::Some(type_::Type::Union(v))
    }

    // Mutable pointer to the field.
    pub fn mut_union(&mut self) -> &mut type_::Union {
        if let ::std::option::Option::Some(type_::Type::Union(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(type_::Type::Union(type_::Union::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Union(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_union(&mut self) -> type_::Union {
        if self.has_union() {
            match self.type_.take() {
                ::std::option::Option::Some(type_::Type::Union(v)) => v,
                _ => panic!(),
            }
        } else {
            type_::Union::new()
        }
    }

    // .sarus_data_spec.Type.Optional optional = 13;

    pub fn optional(&self) -> &type_::Optional {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Optional(ref v)) => v,
            _ => <type_::Optional as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_optional(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Optional(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: type_::Optional) {
        self.type_ = ::std::option::Option::Some(type_::Type::Optional(v))
    }

    // Mutable pointer to the field.
    pub fn mut_optional(&mut self) -> &mut type_::Optional {
        if let ::std::option::Option::Some(type_::Type::Optional(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(type_::Type::Optional(type_::Optional::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Optional(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_optional(&mut self) -> type_::Optional {
        if self.has_optional() {
            match self.type_.take() {
                ::std::option::Option::Some(type_::Type::Optional(v)) => v,
                _ => panic!(),
            }
        } else {
            type_::Optional::new()
        }
    }

    // .sarus_data_spec.Type.List list = 14;

    pub fn list(&self) -> &type_::List {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::List(ref v)) => v,
            _ => <type_::List as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_list(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_list(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::List(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_list(&mut self, v: type_::List) {
        self.type_ = ::std::option::Option::Some(type_::Type::List(v))
    }

    // Mutable pointer to the field.
    pub fn mut_list(&mut self) -> &mut type_::List {
        if let ::std::option::Option::Some(type_::Type::List(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(type_::Type::List(type_::List::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(type_::Type::List(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_list(&mut self) -> type_::List {
        if self.has_list() {
            match self.type_.take() {
                ::std::option::Option::Some(type_::Type::List(v)) => v,
                _ => panic!(),
            }
        } else {
            type_::List::new()
        }
    }

    // .sarus_data_spec.Type.Array array = 15;

    pub fn array(&self) -> &type_::Array {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Array(ref v)) => v,
            _ => <type_::Array as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_array(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_array(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Array(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_array(&mut self, v: type_::Array) {
        self.type_ = ::std::option::Option::Some(type_::Type::Array(v))
    }

    // Mutable pointer to the field.
    pub fn mut_array(&mut self) -> &mut type_::Array {
        if let ::std::option::Option::Some(type_::Type::Array(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(type_::Type::Array(type_::Array::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Array(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_array(&mut self) -> type_::Array {
        if self.has_array() {
            match self.type_.take() {
                ::std::option::Option::Some(type_::Type::Array(v)) => v,
                _ => panic!(),
            }
        } else {
            type_::Array::new()
        }
    }

    // .sarus_data_spec.Type.Datetime datetime = 16;

    pub fn datetime(&self) -> &type_::Datetime {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Datetime(ref v)) => v,
            _ => <type_::Datetime as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_datetime(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_datetime(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Datetime(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_datetime(&mut self, v: type_::Datetime) {
        self.type_ = ::std::option::Option::Some(type_::Type::Datetime(v))
    }

    // Mutable pointer to the field.
    pub fn mut_datetime(&mut self) -> &mut type_::Datetime {
        if let ::std::option::Option::Some(type_::Type::Datetime(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(type_::Type::Datetime(type_::Datetime::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Datetime(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_datetime(&mut self) -> type_::Datetime {
        if self.has_datetime() {
            match self.type_.take() {
                ::std::option::Option::Some(type_::Type::Datetime(v)) => v,
                _ => panic!(),
            }
        } else {
            type_::Datetime::new()
        }
    }

    // .sarus_data_spec.Type.Constrained constrained = 17;

    pub fn constrained(&self) -> &type_::Constrained {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Constrained(ref v)) => v,
            _ => <type_::Constrained as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_constrained(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_constrained(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Constrained(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_constrained(&mut self, v: type_::Constrained) {
        self.type_ = ::std::option::Option::Some(type_::Type::Constrained(v))
    }

    // Mutable pointer to the field.
    pub fn mut_constrained(&mut self) -> &mut type_::Constrained {
        if let ::std::option::Option::Some(type_::Type::Constrained(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(type_::Type::Constrained(type_::Constrained::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Constrained(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_constrained(&mut self) -> type_::Constrained {
        if self.has_constrained() {
            match self.type_.take() {
                ::std::option::Option::Some(type_::Type::Constrained(v)) => v,
                _ => panic!(),
            }
        } else {
            type_::Constrained::new()
        }
    }

    // .sarus_data_spec.Type.Hypothesis hypothesis = 18;

    pub fn hypothesis(&self) -> &type_::Hypothesis {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Hypothesis(ref v)) => v,
            _ => <type_::Hypothesis as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_hypothesis(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_hypothesis(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Hypothesis(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hypothesis(&mut self, v: type_::Hypothesis) {
        self.type_ = ::std::option::Option::Some(type_::Type::Hypothesis(v))
    }

    // Mutable pointer to the field.
    pub fn mut_hypothesis(&mut self) -> &mut type_::Hypothesis {
        if let ::std::option::Option::Some(type_::Type::Hypothesis(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(type_::Type::Hypothesis(type_::Hypothesis::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Hypothesis(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hypothesis(&mut self) -> type_::Hypothesis {
        if self.has_hypothesis() {
            match self.type_.take() {
                ::std::option::Option::Some(type_::Type::Hypothesis(v)) => v,
                _ => panic!(),
            }
        } else {
            type_::Hypothesis::new()
        }
    }

    // .sarus_data_spec.Type.Id id = 19;

    pub fn id(&self) -> &type_::Id {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Id(ref v)) => v,
            _ => <type_::Id as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_id(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: type_::Id) {
        self.type_ = ::std::option::Option::Some(type_::Type::Id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_id(&mut self) -> &mut type_::Id {
        if let ::std::option::Option::Some(type_::Type::Id(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(type_::Type::Id(type_::Id::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_id(&mut self) -> type_::Id {
        if self.has_id() {
            match self.type_.take() {
                ::std::option::Option::Some(type_::Type::Id(v)) => v,
                _ => panic!(),
            }
        } else {
            type_::Id::new()
        }
    }

    // .sarus_data_spec.Type.Date date = 20;

    pub fn date(&self) -> &type_::Date {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Date(ref v)) => v,
            _ => <type_::Date as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_date(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_date(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Date(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: type_::Date) {
        self.type_ = ::std::option::Option::Some(type_::Type::Date(v))
    }

    // Mutable pointer to the field.
    pub fn mut_date(&mut self) -> &mut type_::Date {
        if let ::std::option::Option::Some(type_::Type::Date(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(type_::Type::Date(type_::Date::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Date(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_date(&mut self) -> type_::Date {
        if self.has_date() {
            match self.type_.take() {
                ::std::option::Option::Some(type_::Type::Date(v)) => v,
                _ => panic!(),
            }
        } else {
            type_::Date::new()
        }
    }

    // .sarus_data_spec.Type.Time time = 21;

    pub fn time(&self) -> &type_::Time {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Time(ref v)) => v,
            _ => <type_::Time as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_time(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Time(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: type_::Time) {
        self.type_ = ::std::option::Option::Some(type_::Type::Time(v))
    }

    // Mutable pointer to the field.
    pub fn mut_time(&mut self) -> &mut type_::Time {
        if let ::std::option::Option::Some(type_::Type::Time(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(type_::Type::Time(type_::Time::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Time(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_time(&mut self) -> type_::Time {
        if self.has_time() {
            match self.type_.take() {
                ::std::option::Option::Some(type_::Type::Time(v)) => v,
                _ => panic!(),
            }
        } else {
            type_::Time::new()
        }
    }

    // .sarus_data_spec.Type.Duration duration = 22;

    pub fn duration(&self) -> &type_::Duration {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Duration(ref v)) => v,
            _ => <type_::Duration as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_duration(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Duration(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: type_::Duration) {
        self.type_ = ::std::option::Option::Some(type_::Type::Duration(v))
    }

    // Mutable pointer to the field.
    pub fn mut_duration(&mut self) -> &mut type_::Duration {
        if let ::std::option::Option::Some(type_::Type::Duration(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(type_::Type::Duration(type_::Duration::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(type_::Type::Duration(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_duration(&mut self) -> type_::Duration {
        if self.has_duration() {
            match self.type_.take() {
                ::std::option::Option::Some(type_::Type::Duration(v)) => v,
                _ => panic!(),
            }
        } else {
            type_::Duration::new()
        }
    }

    // repeated .sarus_data_spec.Type.PropertiesEntry properties = 2;

    pub fn properties(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.properties
    }

    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.properties, ::std::collections::HashMap::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(22);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Type| { &m.name },
            |m: &mut Type| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, type_::Null>(
            "null",
            Type::has_null,
            Type::null,
            Type::mut_null,
            Type::set_null,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, type_::Unit>(
            "unit",
            Type::has_unit,
            Type::unit,
            Type::mut_unit,
            Type::set_unit,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, type_::Boolean>(
            "boolean",
            Type::has_boolean,
            Type::boolean,
            Type::mut_boolean,
            Type::set_boolean,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, type_::Integer>(
            "integer",
            Type::has_integer,
            Type::integer,
            Type::mut_integer,
            Type::set_integer,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, type_::Enum>(
            "enum",
            Type::has_enum,
            Type::enum_,
            Type::mut_enum,
            Type::set_enum,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, type_::Float>(
            "float",
            Type::has_float,
            Type::float,
            Type::mut_float,
            Type::set_float,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, type_::Text>(
            "text",
            Type::has_text,
            Type::text,
            Type::mut_text,
            Type::set_text,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, type_::Bytes>(
            "bytes",
            Type::has_bytes,
            Type::bytes,
            Type::mut_bytes,
            Type::set_bytes,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, type_::Struct>(
            "struct",
            Type::has_struct,
            Type::struct_,
            Type::mut_struct,
            Type::set_struct,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, type_::Union>(
            "union",
            Type::has_union,
            Type::union,
            Type::mut_union,
            Type::set_union,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, type_::Optional>(
            "optional",
            Type::has_optional,
            Type::optional,
            Type::mut_optional,
            Type::set_optional,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, type_::List>(
            "list",
            Type::has_list,
            Type::list,
            Type::mut_list,
            Type::set_list,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, type_::Array>(
            "array",
            Type::has_array,
            Type::array,
            Type::mut_array,
            Type::set_array,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, type_::Datetime>(
            "datetime",
            Type::has_datetime,
            Type::datetime,
            Type::mut_datetime,
            Type::set_datetime,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, type_::Constrained>(
            "constrained",
            Type::has_constrained,
            Type::constrained,
            Type::mut_constrained,
            Type::set_constrained,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, type_::Hypothesis>(
            "hypothesis",
            Type::has_hypothesis,
            Type::hypothesis,
            Type::mut_hypothesis,
            Type::set_hypothesis,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, type_::Id>(
            "id",
            Type::has_id,
            Type::id,
            Type::mut_id,
            Type::set_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, type_::Date>(
            "date",
            Type::has_date,
            Type::date,
            Type::mut_date,
            Type::set_date,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, type_::Time>(
            "time",
            Type::has_time,
            Type::time,
            Type::mut_time,
            Type::set_time,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, type_::Duration>(
            "duration",
            Type::has_duration,
            Type::duration,
            Type::mut_duration,
            Type::set_duration,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "properties",
            |m: &Type| { &m.properties },
            |m: &mut Type| { &mut m.properties },
        ));
        oneofs.push(type_::Type::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Type>(
            "Type",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Type {
    const NAME: &'static str = "Type";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.type_ = ::std::option::Option::Some(type_::Type::Null(is.read_message()?));
                },
                34 => {
                    self.type_ = ::std::option::Option::Some(type_::Type::Unit(is.read_message()?));
                },
                42 => {
                    self.type_ = ::std::option::Option::Some(type_::Type::Boolean(is.read_message()?));
                },
                50 => {
                    self.type_ = ::std::option::Option::Some(type_::Type::Integer(is.read_message()?));
                },
                58 => {
                    self.type_ = ::std::option::Option::Some(type_::Type::Enum(is.read_message()?));
                },
                66 => {
                    self.type_ = ::std::option::Option::Some(type_::Type::Float(is.read_message()?));
                },
                74 => {
                    self.type_ = ::std::option::Option::Some(type_::Type::Text(is.read_message()?));
                },
                82 => {
                    self.type_ = ::std::option::Option::Some(type_::Type::Bytes(is.read_message()?));
                },
                90 => {
                    self.type_ = ::std::option::Option::Some(type_::Type::Struct(is.read_message()?));
                },
                98 => {
                    self.type_ = ::std::option::Option::Some(type_::Type::Union(is.read_message()?));
                },
                106 => {
                    self.type_ = ::std::option::Option::Some(type_::Type::Optional(is.read_message()?));
                },
                114 => {
                    self.type_ = ::std::option::Option::Some(type_::Type::List(is.read_message()?));
                },
                122 => {
                    self.type_ = ::std::option::Option::Some(type_::Type::Array(is.read_message()?));
                },
                130 => {
                    self.type_ = ::std::option::Option::Some(type_::Type::Datetime(is.read_message()?));
                },
                138 => {
                    self.type_ = ::std::option::Option::Some(type_::Type::Constrained(is.read_message()?));
                },
                146 => {
                    self.type_ = ::std::option::Option::Some(type_::Type::Hypothesis(is.read_message()?));
                },
                154 => {
                    self.type_ = ::std::option::Option::Some(type_::Type::Id(is.read_message()?));
                },
                162 => {
                    self.type_ = ::std::option::Option::Some(type_::Type::Date(is.read_message()?));
                },
                170 => {
                    self.type_ = ::std::option::Option::Some(type_::Type::Time(is.read_message()?));
                },
                178 => {
                    self.type_ = ::std::option::Option::Some(type_::Type::Duration(is.read_message()?));
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.properties.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for (k, v) in &self.properties {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let ::std::option::Option::Some(ref v) = self.type_ {
            match v {
                &type_::Type::Null(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &type_::Type::Unit(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &type_::Type::Boolean(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &type_::Type::Integer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &type_::Type::Enum(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &type_::Type::Float(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &type_::Type::Text(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &type_::Type::Bytes(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &type_::Type::Struct(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &type_::Type::Union(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &type_::Type::Optional(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &type_::Type::List(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &type_::Type::Array(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &type_::Type::Datetime(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &type_::Type::Constrained(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &type_::Type::Hypothesis(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &type_::Type::Id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &type_::Type::Date(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &type_::Type::Time(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &type_::Type::Duration(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for (k, v) in &self.properties {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let ::std::option::Option::Some(ref v) = self.type_ {
            match v {
                &type_::Type::Null(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &type_::Type::Unit(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &type_::Type::Boolean(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &type_::Type::Integer(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &type_::Type::Enum(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &type_::Type::Float(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &type_::Type::Text(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &type_::Type::Bytes(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &type_::Type::Struct(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &type_::Type::Union(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &type_::Type::Optional(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &type_::Type::List(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                },
                &type_::Type::Array(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
                &type_::Type::Datetime(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
                },
                &type_::Type::Constrained(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
                },
                &type_::Type::Hypothesis(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
                },
                &type_::Type::Id(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
                },
                &type_::Type::Date(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
                },
                &type_::Type::Time(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
                },
                &type_::Type::Duration(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Type {
        Type::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.properties.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Type {
        static instance: ::protobuf::rt::Lazy<Type> = ::protobuf::rt::Lazy::new();
        instance.get(Type::new)
    }
}

impl ::protobuf::MessageFull for Type {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Type").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Type`
pub mod type_ {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:sarus_data_spec.Type.type)
    pub enum Type {
        // @@protoc_insertion_point(oneof_field:sarus_data_spec.Type.null)
        Null(Null),
        // @@protoc_insertion_point(oneof_field:sarus_data_spec.Type.unit)
        Unit(Unit),
        // @@protoc_insertion_point(oneof_field:sarus_data_spec.Type.boolean)
        Boolean(Boolean),
        // @@protoc_insertion_point(oneof_field:sarus_data_spec.Type.integer)
        Integer(Integer),
        // @@protoc_insertion_point(oneof_field:sarus_data_spec.Type.enum)
        Enum(Enum),
        // @@protoc_insertion_point(oneof_field:sarus_data_spec.Type.float)
        Float(Float),
        // @@protoc_insertion_point(oneof_field:sarus_data_spec.Type.text)
        Text(Text),
        // @@protoc_insertion_point(oneof_field:sarus_data_spec.Type.bytes)
        Bytes(Bytes),
        // @@protoc_insertion_point(oneof_field:sarus_data_spec.Type.struct)
        Struct(Struct),
        // @@protoc_insertion_point(oneof_field:sarus_data_spec.Type.union)
        Union(Union),
        // @@protoc_insertion_point(oneof_field:sarus_data_spec.Type.optional)
        Optional(Optional),
        // @@protoc_insertion_point(oneof_field:sarus_data_spec.Type.list)
        List(List),
        // @@protoc_insertion_point(oneof_field:sarus_data_spec.Type.array)
        Array(Array),
        // @@protoc_insertion_point(oneof_field:sarus_data_spec.Type.datetime)
        Datetime(Datetime),
        // @@protoc_insertion_point(oneof_field:sarus_data_spec.Type.constrained)
        Constrained(Constrained),
        // @@protoc_insertion_point(oneof_field:sarus_data_spec.Type.hypothesis)
        Hypothesis(Hypothesis),
        // @@protoc_insertion_point(oneof_field:sarus_data_spec.Type.id)
        Id(Id),
        // @@protoc_insertion_point(oneof_field:sarus_data_spec.Type.date)
        Date(Date),
        // @@protoc_insertion_point(oneof_field:sarus_data_spec.Type.time)
        Time(Time),
        // @@protoc_insertion_point(oneof_field:sarus_data_spec.Type.duration)
        Duration(Duration),
    }

    impl ::protobuf::Oneof for Type {
    }

    impl ::protobuf::OneofFull for Type {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Type as ::protobuf::MessageFull>::descriptor().oneof_by_name("type").unwrap()).clone()
        }
    }

    impl Type {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Type>("type")
        }
    }
    // @@protoc_insertion_point(message:sarus_data_spec.Type.Null)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Null {
        // special fields
        // @@protoc_insertion_point(special_field:sarus_data_spec.Type.Null.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Null {
        fn default() -> &'a Null {
            <Null as ::protobuf::Message>::default_instance()
        }
    }

    impl Null {
        pub fn new() -> Null {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Null>(
                "Type.Null",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Null {
        const NAME: &'static str = "Null";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Null {
            Null::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Null {
            static instance: Null = Null {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Null {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Type.Null").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Null {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Null {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:sarus_data_spec.Type.Unit)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Unit {
        // special fields
        // @@protoc_insertion_point(special_field:sarus_data_spec.Type.Unit.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Unit {
        fn default() -> &'a Unit {
            <Unit as ::protobuf::Message>::default_instance()
        }
    }

    impl Unit {
        pub fn new() -> Unit {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Unit>(
                "Type.Unit",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Unit {
        const NAME: &'static str = "Unit";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Unit {
            Unit::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Unit {
            static instance: Unit = Unit {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Unit {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Type.Unit").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Unit {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Unit {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:sarus_data_spec.Type.Boolean)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Boolean {
        // special fields
        // @@protoc_insertion_point(special_field:sarus_data_spec.Type.Boolean.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Boolean {
        fn default() -> &'a Boolean {
            <Boolean as ::protobuf::Message>::default_instance()
        }
    }

    impl Boolean {
        pub fn new() -> Boolean {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Boolean>(
                "Type.Boolean",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Boolean {
        const NAME: &'static str = "Boolean";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Boolean {
            Boolean::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Boolean {
            static instance: Boolean = Boolean {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Boolean {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Type.Boolean").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Boolean {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Boolean {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:sarus_data_spec.Type.Integer)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Integer {
        // message fields
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Integer.base)
        pub base: ::protobuf::EnumOrUnknown<integer::Base>,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Integer.min)
        pub min: i64,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Integer.max)
        pub max: i64,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Integer.possible_values)
        pub possible_values: ::std::vec::Vec<i64>,
        // special fields
        // @@protoc_insertion_point(special_field:sarus_data_spec.Type.Integer.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Integer {
        fn default() -> &'a Integer {
            <Integer as ::protobuf::Message>::default_instance()
        }
    }

    impl Integer {
        pub fn new() -> Integer {
            ::std::default::Default::default()
        }

        // .sarus_data_spec.Type.Integer.Base base = 1;

        pub fn base(&self) -> integer::Base {
            self.base.enum_value_or_default()
        }

        pub fn clear_base(&mut self) {
            self.base = ::protobuf::EnumOrUnknown::new(integer::Base::INT64);
        }

        // Param is passed by value, moved
        pub fn set_base(&mut self, v: integer::Base) {
            self.base = ::protobuf::EnumOrUnknown::new(v);
        }

        // int64 min = 2;

        pub fn min(&self) -> i64 {
            self.min
        }

        pub fn clear_min(&mut self) {
            self.min = 0;
        }

        // Param is passed by value, moved
        pub fn set_min(&mut self, v: i64) {
            self.min = v;
        }

        // int64 max = 3;

        pub fn max(&self) -> i64 {
            self.max
        }

        pub fn clear_max(&mut self) {
            self.max = 0;
        }

        // Param is passed by value, moved
        pub fn set_max(&mut self, v: i64) {
            self.max = v;
        }

        // repeated int64 possible_values = 4;

        pub fn possible_values(&self) -> &[i64] {
            &self.possible_values
        }

        pub fn clear_possible_values(&mut self) {
            self.possible_values.clear();
        }

        // Param is passed by value, moved
        pub fn set_possible_values(&mut self, v: ::std::vec::Vec<i64>) {
            self.possible_values = v;
        }

        // Mutable pointer to the field.
        pub fn mut_possible_values(&mut self) -> &mut ::std::vec::Vec<i64> {
            &mut self.possible_values
        }

        // Take field
        pub fn take_possible_values(&mut self) -> ::std::vec::Vec<i64> {
            ::std::mem::replace(&mut self.possible_values, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "base",
                |m: &Integer| { &m.base },
                |m: &mut Integer| { &mut m.base },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "min",
                |m: &Integer| { &m.min },
                |m: &mut Integer| { &mut m.min },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "max",
                |m: &Integer| { &m.max },
                |m: &mut Integer| { &mut m.max },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "possible_values",
                |m: &Integer| { &m.possible_values },
                |m: &mut Integer| { &mut m.possible_values },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Integer>(
                "Type.Integer",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Integer {
        const NAME: &'static str = "Integer";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.base = is.read_enum_or_unknown()?;
                    },
                    16 => {
                        self.min = is.read_int64()?;
                    },
                    24 => {
                        self.max = is.read_int64()?;
                    },
                    34 => {
                        is.read_repeated_packed_int64_into(&mut self.possible_values)?;
                    },
                    32 => {
                        self.possible_values.push(is.read_int64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.base != ::protobuf::EnumOrUnknown::new(integer::Base::INT64) {
                my_size += ::protobuf::rt::int32_size(1, self.base.value());
            }
            if self.min != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.min);
            }
            if self.max != 0 {
                my_size += ::protobuf::rt::int64_size(3, self.max);
            }
            for value in &self.possible_values {
                my_size += ::protobuf::rt::int64_size(4, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.base != ::protobuf::EnumOrUnknown::new(integer::Base::INT64) {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.base))?;
            }
            if self.min != 0 {
                os.write_int64(2, self.min)?;
            }
            if self.max != 0 {
                os.write_int64(3, self.max)?;
            }
            for v in &self.possible_values {
                os.write_int64(4, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Integer {
            Integer::new()
        }

        fn clear(&mut self) {
            self.base = ::protobuf::EnumOrUnknown::new(integer::Base::INT64);
            self.min = 0;
            self.max = 0;
            self.possible_values.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Integer {
            static instance: Integer = Integer {
                base: ::protobuf::EnumOrUnknown::from_i32(0),
                min: 0,
                max: 0,
                possible_values: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Integer {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Type.Integer").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Integer {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Integer {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Integer`
    pub mod integer {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:sarus_data_spec.Type.Integer.Base)
        pub enum Base {
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Integer.Base.INT64)
            INT64 = 0,
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Integer.Base.INT32)
            INT32 = 1,
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Integer.Base.INT16)
            INT16 = 2,
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Integer.Base.INT8)
            INT8 = 3,
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Integer.Base.UINT64)
            UINT64 = 4,
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Integer.Base.UINT32)
            UINT32 = 5,
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Integer.Base.UINT16)
            UINT16 = 6,
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Integer.Base.UINT8)
            UINT8 = 7,
        }

        impl ::protobuf::Enum for Base {
            const NAME: &'static str = "Base";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Base> {
                match value {
                    0 => ::std::option::Option::Some(Base::INT64),
                    1 => ::std::option::Option::Some(Base::INT32),
                    2 => ::std::option::Option::Some(Base::INT16),
                    3 => ::std::option::Option::Some(Base::INT8),
                    4 => ::std::option::Option::Some(Base::UINT64),
                    5 => ::std::option::Option::Some(Base::UINT32),
                    6 => ::std::option::Option::Some(Base::UINT16),
                    7 => ::std::option::Option::Some(Base::UINT8),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<Base> {
                match str {
                    "INT64" => ::std::option::Option::Some(Base::INT64),
                    "INT32" => ::std::option::Option::Some(Base::INT32),
                    "INT16" => ::std::option::Option::Some(Base::INT16),
                    "INT8" => ::std::option::Option::Some(Base::INT8),
                    "UINT64" => ::std::option::Option::Some(Base::UINT64),
                    "UINT32" => ::std::option::Option::Some(Base::UINT32),
                    "UINT16" => ::std::option::Option::Some(Base::UINT16),
                    "UINT8" => ::std::option::Option::Some(Base::UINT8),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Base] = &[
                Base::INT64,
                Base::INT32,
                Base::INT16,
                Base::INT8,
                Base::UINT64,
                Base::UINT32,
                Base::UINT16,
                Base::UINT8,
            ];
        }

        impl ::protobuf::EnumFull for Base {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("Type.Integer.Base").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for Base {
            fn default() -> Self {
                Base::INT64
            }
        }

        impl Base {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Base>("Type.Integer.Base")
            }
        }
    }

    // @@protoc_insertion_point(message:sarus_data_spec.Type.Enum)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Enum {
        // message fields
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Enum.base)
        pub base: ::protobuf::EnumOrUnknown<enum_::Base>,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Enum.ordered)
        pub ordered: bool,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Enum.name_values)
        pub name_values: ::std::vec::Vec<enum_::NameValue>,
        // special fields
        // @@protoc_insertion_point(special_field:sarus_data_spec.Type.Enum.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Enum {
        fn default() -> &'a Enum {
            <Enum as ::protobuf::Message>::default_instance()
        }
    }

    impl Enum {
        pub fn new() -> Enum {
            ::std::default::Default::default()
        }

        // .sarus_data_spec.Type.Enum.Base base = 1;

        pub fn base(&self) -> enum_::Base {
            self.base.enum_value_or_default()
        }

        pub fn clear_base(&mut self) {
            self.base = ::protobuf::EnumOrUnknown::new(enum_::Base::INT64);
        }

        // Param is passed by value, moved
        pub fn set_base(&mut self, v: enum_::Base) {
            self.base = ::protobuf::EnumOrUnknown::new(v);
        }

        // bool ordered = 2;

        pub fn ordered(&self) -> bool {
            self.ordered
        }

        pub fn clear_ordered(&mut self) {
            self.ordered = false;
        }

        // Param is passed by value, moved
        pub fn set_ordered(&mut self, v: bool) {
            self.ordered = v;
        }

        // repeated .sarus_data_spec.Type.Enum.NameValue name_values = 3;

        pub fn name_values(&self) -> &[enum_::NameValue] {
            &self.name_values
        }

        pub fn clear_name_values(&mut self) {
            self.name_values.clear();
        }

        // Param is passed by value, moved
        pub fn set_name_values(&mut self, v: ::std::vec::Vec<enum_::NameValue>) {
            self.name_values = v;
        }

        // Mutable pointer to the field.
        pub fn mut_name_values(&mut self) -> &mut ::std::vec::Vec<enum_::NameValue> {
            &mut self.name_values
        }

        // Take field
        pub fn take_name_values(&mut self) -> ::std::vec::Vec<enum_::NameValue> {
            ::std::mem::replace(&mut self.name_values, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "base",
                |m: &Enum| { &m.base },
                |m: &mut Enum| { &mut m.base },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "ordered",
                |m: &Enum| { &m.ordered },
                |m: &mut Enum| { &mut m.ordered },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "name_values",
                |m: &Enum| { &m.name_values },
                |m: &mut Enum| { &mut m.name_values },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Enum>(
                "Type.Enum",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Enum {
        const NAME: &'static str = "Enum";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.base = is.read_enum_or_unknown()?;
                    },
                    16 => {
                        self.ordered = is.read_bool()?;
                    },
                    26 => {
                        self.name_values.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.base != ::protobuf::EnumOrUnknown::new(enum_::Base::INT64) {
                my_size += ::protobuf::rt::int32_size(1, self.base.value());
            }
            if self.ordered != false {
                my_size += 1 + 1;
            }
            for value in &self.name_values {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.base != ::protobuf::EnumOrUnknown::new(enum_::Base::INT64) {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.base))?;
            }
            if self.ordered != false {
                os.write_bool(2, self.ordered)?;
            }
            for v in &self.name_values {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Enum {
            Enum::new()
        }

        fn clear(&mut self) {
            self.base = ::protobuf::EnumOrUnknown::new(enum_::Base::INT64);
            self.ordered = false;
            self.name_values.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Enum {
            static instance: Enum = Enum {
                base: ::protobuf::EnumOrUnknown::from_i32(0),
                ordered: false,
                name_values: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Enum {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Type.Enum").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Enum {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Enum {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Enum`
    pub mod enum_ {
        // @@protoc_insertion_point(message:sarus_data_spec.Type.Enum.NameValue)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct NameValue {
            // message fields
            // @@protoc_insertion_point(field:sarus_data_spec.Type.Enum.NameValue.name)
            pub name: ::std::string::String,
            // @@protoc_insertion_point(field:sarus_data_spec.Type.Enum.NameValue.value)
            pub value: i64,
            // special fields
            // @@protoc_insertion_point(special_field:sarus_data_spec.Type.Enum.NameValue.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a NameValue {
            fn default() -> &'a NameValue {
                <NameValue as ::protobuf::Message>::default_instance()
            }
        }

        impl NameValue {
            pub fn new() -> NameValue {
                ::std::default::Default::default()
            }

            // string name = 1;

            pub fn name(&self) -> &str {
                &self.name
            }

            pub fn clear_name(&mut self) {
                self.name.clear();
            }

            // Param is passed by value, moved
            pub fn set_name(&mut self, v: ::std::string::String) {
                self.name = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_name(&mut self) -> &mut ::std::string::String {
                &mut self.name
            }

            // Take field
            pub fn take_name(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.name, ::std::string::String::new())
            }

            // int64 value = 2;

            pub fn value(&self) -> i64 {
                self.value
            }

            pub fn clear_value(&mut self) {
                self.value = 0;
            }

            // Param is passed by value, moved
            pub fn set_value(&mut self, v: i64) {
                self.value = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "name",
                    |m: &NameValue| { &m.name },
                    |m: &mut NameValue| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "value",
                    |m: &NameValue| { &m.value },
                    |m: &mut NameValue| { &mut m.value },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NameValue>(
                    "Type.Enum.NameValue",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for NameValue {
            const NAME: &'static str = "NameValue";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.name = is.read_string()?;
                        },
                        16 => {
                            self.value = is.read_int64()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.name.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.name);
                }
                if self.value != 0 {
                    my_size += ::protobuf::rt::int64_size(2, self.value);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.name.is_empty() {
                    os.write_string(1, &self.name)?;
                }
                if self.value != 0 {
                    os.write_int64(2, self.value)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> NameValue {
                NameValue::new()
            }

            fn clear(&mut self) {
                self.name.clear();
                self.value = 0;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static NameValue {
                static instance: NameValue = NameValue {
                    name: ::std::string::String::new(),
                    value: 0,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for NameValue {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Type.Enum.NameValue").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for NameValue {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for NameValue {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:sarus_data_spec.Type.Enum.Base)
        pub enum Base {
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Enum.Base.INT64)
            INT64 = 0,
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Enum.Base.INT32)
            INT32 = 1,
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Enum.Base.INT16)
            INT16 = 2,
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Enum.Base.INT8)
            INT8 = 3,
        }

        impl ::protobuf::Enum for Base {
            const NAME: &'static str = "Base";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Base> {
                match value {
                    0 => ::std::option::Option::Some(Base::INT64),
                    1 => ::std::option::Option::Some(Base::INT32),
                    2 => ::std::option::Option::Some(Base::INT16),
                    3 => ::std::option::Option::Some(Base::INT8),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<Base> {
                match str {
                    "INT64" => ::std::option::Option::Some(Base::INT64),
                    "INT32" => ::std::option::Option::Some(Base::INT32),
                    "INT16" => ::std::option::Option::Some(Base::INT16),
                    "INT8" => ::std::option::Option::Some(Base::INT8),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Base] = &[
                Base::INT64,
                Base::INT32,
                Base::INT16,
                Base::INT8,
            ];
        }

        impl ::protobuf::EnumFull for Base {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("Type.Enum.Base").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for Base {
            fn default() -> Self {
                Base::INT64
            }
        }

        impl Base {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Base>("Type.Enum.Base")
            }
        }
    }

    // @@protoc_insertion_point(message:sarus_data_spec.Type.Float)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Float {
        // message fields
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Float.base)
        pub base: ::protobuf::EnumOrUnknown<float::Base>,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Float.min)
        pub min: f64,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Float.max)
        pub max: f64,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Float.possible_values)
        pub possible_values: ::std::vec::Vec<f64>,
        // special fields
        // @@protoc_insertion_point(special_field:sarus_data_spec.Type.Float.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Float {
        fn default() -> &'a Float {
            <Float as ::protobuf::Message>::default_instance()
        }
    }

    impl Float {
        pub fn new() -> Float {
            ::std::default::Default::default()
        }

        // .sarus_data_spec.Type.Float.Base base = 1;

        pub fn base(&self) -> float::Base {
            self.base.enum_value_or_default()
        }

        pub fn clear_base(&mut self) {
            self.base = ::protobuf::EnumOrUnknown::new(float::Base::FLOAT64);
        }

        // Param is passed by value, moved
        pub fn set_base(&mut self, v: float::Base) {
            self.base = ::protobuf::EnumOrUnknown::new(v);
        }

        // double min = 2;

        pub fn min(&self) -> f64 {
            self.min
        }

        pub fn clear_min(&mut self) {
            self.min = 0.;
        }

        // Param is passed by value, moved
        pub fn set_min(&mut self, v: f64) {
            self.min = v;
        }

        // double max = 3;

        pub fn max(&self) -> f64 {
            self.max
        }

        pub fn clear_max(&mut self) {
            self.max = 0.;
        }

        // Param is passed by value, moved
        pub fn set_max(&mut self, v: f64) {
            self.max = v;
        }

        // repeated double possible_values = 4;

        pub fn possible_values(&self) -> &[f64] {
            &self.possible_values
        }

        pub fn clear_possible_values(&mut self) {
            self.possible_values.clear();
        }

        // Param is passed by value, moved
        pub fn set_possible_values(&mut self, v: ::std::vec::Vec<f64>) {
            self.possible_values = v;
        }

        // Mutable pointer to the field.
        pub fn mut_possible_values(&mut self) -> &mut ::std::vec::Vec<f64> {
            &mut self.possible_values
        }

        // Take field
        pub fn take_possible_values(&mut self) -> ::std::vec::Vec<f64> {
            ::std::mem::replace(&mut self.possible_values, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "base",
                |m: &Float| { &m.base },
                |m: &mut Float| { &mut m.base },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "min",
                |m: &Float| { &m.min },
                |m: &mut Float| { &mut m.min },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "max",
                |m: &Float| { &m.max },
                |m: &mut Float| { &mut m.max },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "possible_values",
                |m: &Float| { &m.possible_values },
                |m: &mut Float| { &mut m.possible_values },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Float>(
                "Type.Float",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Float {
        const NAME: &'static str = "Float";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.base = is.read_enum_or_unknown()?;
                    },
                    17 => {
                        self.min = is.read_double()?;
                    },
                    25 => {
                        self.max = is.read_double()?;
                    },
                    34 => {
                        is.read_repeated_packed_double_into(&mut self.possible_values)?;
                    },
                    33 => {
                        self.possible_values.push(is.read_double()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.base != ::protobuf::EnumOrUnknown::new(float::Base::FLOAT64) {
                my_size += ::protobuf::rt::int32_size(1, self.base.value());
            }
            if self.min != 0. {
                my_size += 1 + 8;
            }
            if self.max != 0. {
                my_size += 1 + 8;
            }
            my_size += 9 * self.possible_values.len() as u64;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.base != ::protobuf::EnumOrUnknown::new(float::Base::FLOAT64) {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.base))?;
            }
            if self.min != 0. {
                os.write_double(2, self.min)?;
            }
            if self.max != 0. {
                os.write_double(3, self.max)?;
            }
            for v in &self.possible_values {
                os.write_double(4, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Float {
            Float::new()
        }

        fn clear(&mut self) {
            self.base = ::protobuf::EnumOrUnknown::new(float::Base::FLOAT64);
            self.min = 0.;
            self.max = 0.;
            self.possible_values.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Float {
            static instance: Float = Float {
                base: ::protobuf::EnumOrUnknown::from_i32(0),
                min: 0.,
                max: 0.,
                possible_values: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Float {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Type.Float").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Float {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Float {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Float`
    pub mod float {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:sarus_data_spec.Type.Float.Base)
        pub enum Base {
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Float.Base.FLOAT64)
            FLOAT64 = 0,
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Float.Base.FLOAT32)
            FLOAT32 = 1,
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Float.Base.FLOAT16)
            FLOAT16 = 2,
        }

        impl ::protobuf::Enum for Base {
            const NAME: &'static str = "Base";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Base> {
                match value {
                    0 => ::std::option::Option::Some(Base::FLOAT64),
                    1 => ::std::option::Option::Some(Base::FLOAT32),
                    2 => ::std::option::Option::Some(Base::FLOAT16),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<Base> {
                match str {
                    "FLOAT64" => ::std::option::Option::Some(Base::FLOAT64),
                    "FLOAT32" => ::std::option::Option::Some(Base::FLOAT32),
                    "FLOAT16" => ::std::option::Option::Some(Base::FLOAT16),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Base] = &[
                Base::FLOAT64,
                Base::FLOAT32,
                Base::FLOAT16,
            ];
        }

        impl ::protobuf::EnumFull for Base {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("Type.Float.Base").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for Base {
            fn default() -> Self {
                Base::FLOAT64
            }
        }

        impl Base {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Base>("Type.Float.Base")
            }
        }
    }

    // @@protoc_insertion_point(message:sarus_data_spec.Type.Text)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Text {
        // message fields
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Text.encoding)
        pub encoding: ::std::string::String,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Text.possible_values)
        pub possible_values: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:sarus_data_spec.Type.Text.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Text {
        fn default() -> &'a Text {
            <Text as ::protobuf::Message>::default_instance()
        }
    }

    impl Text {
        pub fn new() -> Text {
            ::std::default::Default::default()
        }

        // string encoding = 1;

        pub fn encoding(&self) -> &str {
            &self.encoding
        }

        pub fn clear_encoding(&mut self) {
            self.encoding.clear();
        }

        // Param is passed by value, moved
        pub fn set_encoding(&mut self, v: ::std::string::String) {
            self.encoding = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_encoding(&mut self) -> &mut ::std::string::String {
            &mut self.encoding
        }

        // Take field
        pub fn take_encoding(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.encoding, ::std::string::String::new())
        }

        // repeated string possible_values = 2;

        pub fn possible_values(&self) -> &[::std::string::String] {
            &self.possible_values
        }

        pub fn clear_possible_values(&mut self) {
            self.possible_values.clear();
        }

        // Param is passed by value, moved
        pub fn set_possible_values(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.possible_values = v;
        }

        // Mutable pointer to the field.
        pub fn mut_possible_values(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.possible_values
        }

        // Take field
        pub fn take_possible_values(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.possible_values, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "encoding",
                |m: &Text| { &m.encoding },
                |m: &mut Text| { &mut m.encoding },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "possible_values",
                |m: &Text| { &m.possible_values },
                |m: &mut Text| { &mut m.possible_values },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Text>(
                "Type.Text",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Text {
        const NAME: &'static str = "Text";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.encoding = is.read_string()?;
                    },
                    18 => {
                        self.possible_values.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.encoding.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.encoding);
            }
            for value in &self.possible_values {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.encoding.is_empty() {
                os.write_string(1, &self.encoding)?;
            }
            for v in &self.possible_values {
                os.write_string(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Text {
            Text::new()
        }

        fn clear(&mut self) {
            self.encoding.clear();
            self.possible_values.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Text {
            static instance: Text = Text {
                encoding: ::std::string::String::new(),
                possible_values: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Text {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Type.Text").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Text {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Text {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:sarus_data_spec.Type.Bytes)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Bytes {
        // special fields
        // @@protoc_insertion_point(special_field:sarus_data_spec.Type.Bytes.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Bytes {
        fn default() -> &'a Bytes {
            <Bytes as ::protobuf::Message>::default_instance()
        }
    }

    impl Bytes {
        pub fn new() -> Bytes {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Bytes>(
                "Type.Bytes",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Bytes {
        const NAME: &'static str = "Bytes";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Bytes {
            Bytes::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Bytes {
            static instance: Bytes = Bytes {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Bytes {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Type.Bytes").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Bytes {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Bytes {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:sarus_data_spec.Type.Struct)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Struct {
        // message fields
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Struct.fields)
        pub fields: ::std::vec::Vec<struct_::Field>,
        // special fields
        // @@protoc_insertion_point(special_field:sarus_data_spec.Type.Struct.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Struct {
        fn default() -> &'a Struct {
            <Struct as ::protobuf::Message>::default_instance()
        }
    }

    impl Struct {
        pub fn new() -> Struct {
            ::std::default::Default::default()
        }

        // repeated .sarus_data_spec.Type.Struct.Field fields = 1;

        pub fn fields(&self) -> &[struct_::Field] {
            &self.fields
        }

        pub fn clear_fields(&mut self) {
            self.fields.clear();
        }

        // Param is passed by value, moved
        pub fn set_fields(&mut self, v: ::std::vec::Vec<struct_::Field>) {
            self.fields = v;
        }

        // Mutable pointer to the field.
        pub fn mut_fields(&mut self) -> &mut ::std::vec::Vec<struct_::Field> {
            &mut self.fields
        }

        // Take field
        pub fn take_fields(&mut self) -> ::std::vec::Vec<struct_::Field> {
            ::std::mem::replace(&mut self.fields, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "fields",
                |m: &Struct| { &m.fields },
                |m: &mut Struct| { &mut m.fields },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Struct>(
                "Type.Struct",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Struct {
        const NAME: &'static str = "Struct";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.fields.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.fields {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.fields {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Struct {
            Struct::new()
        }

        fn clear(&mut self) {
            self.fields.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Struct {
            static instance: Struct = Struct {
                fields: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Struct {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Type.Struct").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Struct {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Struct {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Struct`
    pub mod struct_ {
        // @@protoc_insertion_point(message:sarus_data_spec.Type.Struct.Field)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Field {
            // message fields
            // @@protoc_insertion_point(field:sarus_data_spec.Type.Struct.Field.name)
            pub name: ::std::string::String,
            // @@protoc_insertion_point(field:sarus_data_spec.Type.Struct.Field.type)
            pub type_: ::protobuf::MessageField<super::super::Type>,
            // special fields
            // @@protoc_insertion_point(special_field:sarus_data_spec.Type.Struct.Field.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Field {
            fn default() -> &'a Field {
                <Field as ::protobuf::Message>::default_instance()
            }
        }

        impl Field {
            pub fn new() -> Field {
                ::std::default::Default::default()
            }

            // string name = 1;

            pub fn name(&self) -> &str {
                &self.name
            }

            pub fn clear_name(&mut self) {
                self.name.clear();
            }

            // Param is passed by value, moved
            pub fn set_name(&mut self, v: ::std::string::String) {
                self.name = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_name(&mut self) -> &mut ::std::string::String {
                &mut self.name
            }

            // Take field
            pub fn take_name(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.name, ::std::string::String::new())
            }

            // .sarus_data_spec.Type type = 2;

            pub fn type_(&self) -> &super::super::Type {
                self.type_.as_ref().unwrap_or_else(|| <super::super::Type as ::protobuf::Message>::default_instance())
            }

            pub fn clear_type_(&mut self) {
                self.type_.clear();
            }

            pub fn has_type(&self) -> bool {
                self.type_.is_some()
            }

            // Param is passed by value, moved
            pub fn set_type(&mut self, v: super::super::Type) {
                self.type_ = ::protobuf::MessageField::some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_type(&mut self) -> &mut super::super::Type {
                self.type_.mut_or_insert_default()
            }

            // Take field
            pub fn take_type_(&mut self) -> super::super::Type {
                self.type_.take().unwrap_or_else(|| super::super::Type::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "name",
                    |m: &Field| { &m.name },
                    |m: &mut Field| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::Type>(
                    "type",
                    |m: &Field| { &m.type_ },
                    |m: &mut Field| { &mut m.type_ },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Field>(
                    "Type.Struct.Field",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Field {
            const NAME: &'static str = "Field";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.name = is.read_string()?;
                        },
                        18 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.type_)?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.name.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.name);
                }
                if let Some(v) = self.type_.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.name.is_empty() {
                    os.write_string(1, &self.name)?;
                }
                if let Some(v) = self.type_.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Field {
                Field::new()
            }

            fn clear(&mut self) {
                self.name.clear();
                self.type_.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Field {
                static instance: Field = Field {
                    name: ::std::string::String::new(),
                    type_: ::protobuf::MessageField::none(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Field {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Type.Struct.Field").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Field {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Field {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:sarus_data_spec.Type.Union)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Union {
        // message fields
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Union.fields)
        pub fields: ::std::vec::Vec<union::Field>,
        // special fields
        // @@protoc_insertion_point(special_field:sarus_data_spec.Type.Union.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Union {
        fn default() -> &'a Union {
            <Union as ::protobuf::Message>::default_instance()
        }
    }

    impl Union {
        pub fn new() -> Union {
            ::std::default::Default::default()
        }

        // repeated .sarus_data_spec.Type.Union.Field fields = 1;

        pub fn fields(&self) -> &[union::Field] {
            &self.fields
        }

        pub fn clear_fields(&mut self) {
            self.fields.clear();
        }

        // Param is passed by value, moved
        pub fn set_fields(&mut self, v: ::std::vec::Vec<union::Field>) {
            self.fields = v;
        }

        // Mutable pointer to the field.
        pub fn mut_fields(&mut self) -> &mut ::std::vec::Vec<union::Field> {
            &mut self.fields
        }

        // Take field
        pub fn take_fields(&mut self) -> ::std::vec::Vec<union::Field> {
            ::std::mem::replace(&mut self.fields, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "fields",
                |m: &Union| { &m.fields },
                |m: &mut Union| { &mut m.fields },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Union>(
                "Type.Union",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Union {
        const NAME: &'static str = "Union";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.fields.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.fields {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.fields {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Union {
            Union::new()
        }

        fn clear(&mut self) {
            self.fields.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Union {
            static instance: Union = Union {
                fields: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Union {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Type.Union").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Union {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Union {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Union`
    pub mod union {
        // @@protoc_insertion_point(message:sarus_data_spec.Type.Union.Field)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Field {
            // message fields
            // @@protoc_insertion_point(field:sarus_data_spec.Type.Union.Field.name)
            pub name: ::std::string::String,
            // @@protoc_insertion_point(field:sarus_data_spec.Type.Union.Field.type)
            pub type_: ::protobuf::MessageField<super::super::Type>,
            // special fields
            // @@protoc_insertion_point(special_field:sarus_data_spec.Type.Union.Field.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Field {
            fn default() -> &'a Field {
                <Field as ::protobuf::Message>::default_instance()
            }
        }

        impl Field {
            pub fn new() -> Field {
                ::std::default::Default::default()
            }

            // string name = 1;

            pub fn name(&self) -> &str {
                &self.name
            }

            pub fn clear_name(&mut self) {
                self.name.clear();
            }

            // Param is passed by value, moved
            pub fn set_name(&mut self, v: ::std::string::String) {
                self.name = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_name(&mut self) -> &mut ::std::string::String {
                &mut self.name
            }

            // Take field
            pub fn take_name(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.name, ::std::string::String::new())
            }

            // .sarus_data_spec.Type type = 2;

            pub fn type_(&self) -> &super::super::Type {
                self.type_.as_ref().unwrap_or_else(|| <super::super::Type as ::protobuf::Message>::default_instance())
            }

            pub fn clear_type_(&mut self) {
                self.type_.clear();
            }

            pub fn has_type(&self) -> bool {
                self.type_.is_some()
            }

            // Param is passed by value, moved
            pub fn set_type(&mut self, v: super::super::Type) {
                self.type_ = ::protobuf::MessageField::some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_type(&mut self) -> &mut super::super::Type {
                self.type_.mut_or_insert_default()
            }

            // Take field
            pub fn take_type_(&mut self) -> super::super::Type {
                self.type_.take().unwrap_or_else(|| super::super::Type::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "name",
                    |m: &Field| { &m.name },
                    |m: &mut Field| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::Type>(
                    "type",
                    |m: &Field| { &m.type_ },
                    |m: &mut Field| { &mut m.type_ },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Field>(
                    "Type.Union.Field",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Field {
            const NAME: &'static str = "Field";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.name = is.read_string()?;
                        },
                        18 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.type_)?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.name.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.name);
                }
                if let Some(v) = self.type_.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.name.is_empty() {
                    os.write_string(1, &self.name)?;
                }
                if let Some(v) = self.type_.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Field {
                Field::new()
            }

            fn clear(&mut self) {
                self.name.clear();
                self.type_.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Field {
                static instance: Field = Field {
                    name: ::std::string::String::new(),
                    type_: ::protobuf::MessageField::none(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Field {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Type.Union.Field").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Field {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Field {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:sarus_data_spec.Type.Optional)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Optional {
        // message fields
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Optional.type)
        pub type_: ::protobuf::MessageField<super::Type>,
        // special fields
        // @@protoc_insertion_point(special_field:sarus_data_spec.Type.Optional.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Optional {
        fn default() -> &'a Optional {
            <Optional as ::protobuf::Message>::default_instance()
        }
    }

    impl Optional {
        pub fn new() -> Optional {
            ::std::default::Default::default()
        }

        // .sarus_data_spec.Type type = 1;

        pub fn type_(&self) -> &super::Type {
            self.type_.as_ref().unwrap_or_else(|| <super::Type as ::protobuf::Message>::default_instance())
        }

        pub fn clear_type_(&mut self) {
            self.type_.clear();
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: super::Type) {
            self.type_ = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_type(&mut self) -> &mut super::Type {
            self.type_.mut_or_insert_default()
        }

        // Take field
        pub fn take_type_(&mut self) -> super::Type {
            self.type_.take().unwrap_or_else(|| super::Type::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Type>(
                "type",
                |m: &Optional| { &m.type_ },
                |m: &mut Optional| { &mut m.type_ },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Optional>(
                "Type.Optional",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Optional {
        const NAME: &'static str = "Optional";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.type_)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Optional {
            Optional::new()
        }

        fn clear(&mut self) {
            self.type_.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Optional {
            static instance: Optional = Optional {
                type_: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Optional {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Type.Optional").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Optional {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Optional {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:sarus_data_spec.Type.List)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct List {
        // message fields
        // @@protoc_insertion_point(field:sarus_data_spec.Type.List.type)
        pub type_: ::protobuf::MessageField<super::Type>,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.List.max_size)
        pub max_size: i64,
        // special fields
        // @@protoc_insertion_point(special_field:sarus_data_spec.Type.List.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a List {
        fn default() -> &'a List {
            <List as ::protobuf::Message>::default_instance()
        }
    }

    impl List {
        pub fn new() -> List {
            ::std::default::Default::default()
        }

        // .sarus_data_spec.Type type = 1;

        pub fn type_(&self) -> &super::Type {
            self.type_.as_ref().unwrap_or_else(|| <super::Type as ::protobuf::Message>::default_instance())
        }

        pub fn clear_type_(&mut self) {
            self.type_.clear();
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: super::Type) {
            self.type_ = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_type(&mut self) -> &mut super::Type {
            self.type_.mut_or_insert_default()
        }

        // Take field
        pub fn take_type_(&mut self) -> super::Type {
            self.type_.take().unwrap_or_else(|| super::Type::new())
        }

        // int64 max_size = 2;

        pub fn max_size(&self) -> i64 {
            self.max_size
        }

        pub fn clear_max_size(&mut self) {
            self.max_size = 0;
        }

        // Param is passed by value, moved
        pub fn set_max_size(&mut self, v: i64) {
            self.max_size = v;
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Type>(
                "type",
                |m: &List| { &m.type_ },
                |m: &mut List| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "max_size",
                |m: &List| { &m.max_size },
                |m: &mut List| { &mut m.max_size },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<List>(
                "Type.List",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for List {
        const NAME: &'static str = "List";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.type_)?;
                    },
                    16 => {
                        self.max_size = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.max_size != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.max_size);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if self.max_size != 0 {
                os.write_int64(2, self.max_size)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> List {
            List::new()
        }

        fn clear(&mut self) {
            self.type_.clear();
            self.max_size = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static List {
            static instance: List = List {
                type_: ::protobuf::MessageField::none(),
                max_size: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for List {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Type.List").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for List {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for List {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:sarus_data_spec.Type.Array)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Array {
        // message fields
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Array.type)
        pub type_: ::protobuf::MessageField<super::Type>,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Array.shape)
        pub shape: ::std::vec::Vec<i64>,
        // special fields
        // @@protoc_insertion_point(special_field:sarus_data_spec.Type.Array.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Array {
        fn default() -> &'a Array {
            <Array as ::protobuf::Message>::default_instance()
        }
    }

    impl Array {
        pub fn new() -> Array {
            ::std::default::Default::default()
        }

        // .sarus_data_spec.Type type = 1;

        pub fn type_(&self) -> &super::Type {
            self.type_.as_ref().unwrap_or_else(|| <super::Type as ::protobuf::Message>::default_instance())
        }

        pub fn clear_type_(&mut self) {
            self.type_.clear();
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: super::Type) {
            self.type_ = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_type(&mut self) -> &mut super::Type {
            self.type_.mut_or_insert_default()
        }

        // Take field
        pub fn take_type_(&mut self) -> super::Type {
            self.type_.take().unwrap_or_else(|| super::Type::new())
        }

        // repeated int64 shape = 2;

        pub fn shape(&self) -> &[i64] {
            &self.shape
        }

        pub fn clear_shape(&mut self) {
            self.shape.clear();
        }

        // Param is passed by value, moved
        pub fn set_shape(&mut self, v: ::std::vec::Vec<i64>) {
            self.shape = v;
        }

        // Mutable pointer to the field.
        pub fn mut_shape(&mut self) -> &mut ::std::vec::Vec<i64> {
            &mut self.shape
        }

        // Take field
        pub fn take_shape(&mut self) -> ::std::vec::Vec<i64> {
            ::std::mem::replace(&mut self.shape, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Type>(
                "type",
                |m: &Array| { &m.type_ },
                |m: &mut Array| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "shape",
                |m: &Array| { &m.shape },
                |m: &mut Array| { &mut m.shape },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Array>(
                "Type.Array",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Array {
        const NAME: &'static str = "Array";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.type_)?;
                    },
                    18 => {
                        is.read_repeated_packed_int64_into(&mut self.shape)?;
                    },
                    16 => {
                        self.shape.push(is.read_int64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.shape {
                my_size += ::protobuf::rt::int64_size(2, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            for v in &self.shape {
                os.write_int64(2, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Array {
            Array::new()
        }

        fn clear(&mut self) {
            self.type_.clear();
            self.shape.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Array {
            static instance: Array = Array {
                type_: ::protobuf::MessageField::none(),
                shape: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Array {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Type.Array").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Array {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Array {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:sarus_data_spec.Type.Datetime)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Datetime {
        // message fields
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Datetime.format)
        pub format: ::std::string::String,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Datetime.min)
        pub min: ::std::string::String,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Datetime.max)
        pub max: ::std::string::String,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Datetime.possible_values)
        pub possible_values: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Datetime.base)
        pub base: ::protobuf::EnumOrUnknown<datetime::Base>,
        // special fields
        // @@protoc_insertion_point(special_field:sarus_data_spec.Type.Datetime.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Datetime {
        fn default() -> &'a Datetime {
            <Datetime as ::protobuf::Message>::default_instance()
        }
    }

    impl Datetime {
        pub fn new() -> Datetime {
            ::std::default::Default::default()
        }

        // string format = 1;

        pub fn format(&self) -> &str {
            &self.format
        }

        pub fn clear_format(&mut self) {
            self.format.clear();
        }

        // Param is passed by value, moved
        pub fn set_format(&mut self, v: ::std::string::String) {
            self.format = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_format(&mut self) -> &mut ::std::string::String {
            &mut self.format
        }

        // Take field
        pub fn take_format(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.format, ::std::string::String::new())
        }

        // string min = 2;

        pub fn min(&self) -> &str {
            &self.min
        }

        pub fn clear_min(&mut self) {
            self.min.clear();
        }

        // Param is passed by value, moved
        pub fn set_min(&mut self, v: ::std::string::String) {
            self.min = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_min(&mut self) -> &mut ::std::string::String {
            &mut self.min
        }

        // Take field
        pub fn take_min(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.min, ::std::string::String::new())
        }

        // string max = 3;

        pub fn max(&self) -> &str {
            &self.max
        }

        pub fn clear_max(&mut self) {
            self.max.clear();
        }

        // Param is passed by value, moved
        pub fn set_max(&mut self, v: ::std::string::String) {
            self.max = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_max(&mut self) -> &mut ::std::string::String {
            &mut self.max
        }

        // Take field
        pub fn take_max(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.max, ::std::string::String::new())
        }

        // repeated string possible_values = 4;

        pub fn possible_values(&self) -> &[::std::string::String] {
            &self.possible_values
        }

        pub fn clear_possible_values(&mut self) {
            self.possible_values.clear();
        }

        // Param is passed by value, moved
        pub fn set_possible_values(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.possible_values = v;
        }

        // Mutable pointer to the field.
        pub fn mut_possible_values(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.possible_values
        }

        // Take field
        pub fn take_possible_values(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.possible_values, ::std::vec::Vec::new())
        }

        // .sarus_data_spec.Type.Datetime.Base base = 5;

        pub fn base(&self) -> datetime::Base {
            self.base.enum_value_or_default()
        }

        pub fn clear_base(&mut self) {
            self.base = ::protobuf::EnumOrUnknown::new(datetime::Base::INT64_NS);
        }

        // Param is passed by value, moved
        pub fn set_base(&mut self, v: datetime::Base) {
            self.base = ::protobuf::EnumOrUnknown::new(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "format",
                |m: &Datetime| { &m.format },
                |m: &mut Datetime| { &mut m.format },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "min",
                |m: &Datetime| { &m.min },
                |m: &mut Datetime| { &mut m.min },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "max",
                |m: &Datetime| { &m.max },
                |m: &mut Datetime| { &mut m.max },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "possible_values",
                |m: &Datetime| { &m.possible_values },
                |m: &mut Datetime| { &mut m.possible_values },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "base",
                |m: &Datetime| { &m.base },
                |m: &mut Datetime| { &mut m.base },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Datetime>(
                "Type.Datetime",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Datetime {
        const NAME: &'static str = "Datetime";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.format = is.read_string()?;
                    },
                    18 => {
                        self.min = is.read_string()?;
                    },
                    26 => {
                        self.max = is.read_string()?;
                    },
                    34 => {
                        self.possible_values.push(is.read_string()?);
                    },
                    40 => {
                        self.base = is.read_enum_or_unknown()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.format.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.format);
            }
            if !self.min.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.min);
            }
            if !self.max.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.max);
            }
            for value in &self.possible_values {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            if self.base != ::protobuf::EnumOrUnknown::new(datetime::Base::INT64_NS) {
                my_size += ::protobuf::rt::int32_size(5, self.base.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.format.is_empty() {
                os.write_string(1, &self.format)?;
            }
            if !self.min.is_empty() {
                os.write_string(2, &self.min)?;
            }
            if !self.max.is_empty() {
                os.write_string(3, &self.max)?;
            }
            for v in &self.possible_values {
                os.write_string(4, &v)?;
            };
            if self.base != ::protobuf::EnumOrUnknown::new(datetime::Base::INT64_NS) {
                os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.base))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Datetime {
            Datetime::new()
        }

        fn clear(&mut self) {
            self.format.clear();
            self.min.clear();
            self.max.clear();
            self.possible_values.clear();
            self.base = ::protobuf::EnumOrUnknown::new(datetime::Base::INT64_NS);
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Datetime {
            static instance: Datetime = Datetime {
                format: ::std::string::String::new(),
                min: ::std::string::String::new(),
                max: ::std::string::String::new(),
                possible_values: ::std::vec::Vec::new(),
                base: ::protobuf::EnumOrUnknown::from_i32(0),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Datetime {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Type.Datetime").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Datetime {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Datetime {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Datetime`
    pub mod datetime {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:sarus_data_spec.Type.Datetime.Base)
        pub enum Base {
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Datetime.Base.INT64_NS)
            INT64_NS = 0,
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Datetime.Base.INT64_MS)
            INT64_MS = 1,
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Datetime.Base.STRING)
            STRING = 2,
        }

        impl ::protobuf::Enum for Base {
            const NAME: &'static str = "Base";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Base> {
                match value {
                    0 => ::std::option::Option::Some(Base::INT64_NS),
                    1 => ::std::option::Option::Some(Base::INT64_MS),
                    2 => ::std::option::Option::Some(Base::STRING),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<Base> {
                match str {
                    "INT64_NS" => ::std::option::Option::Some(Base::INT64_NS),
                    "INT64_MS" => ::std::option::Option::Some(Base::INT64_MS),
                    "STRING" => ::std::option::Option::Some(Base::STRING),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Base] = &[
                Base::INT64_NS,
                Base::INT64_MS,
                Base::STRING,
            ];
        }

        impl ::protobuf::EnumFull for Base {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("Type.Datetime.Base").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for Base {
            fn default() -> Self {
                Base::INT64_NS
            }
        }

        impl Base {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Base>("Type.Datetime.Base")
            }
        }
    }

    // @@protoc_insertion_point(message:sarus_data_spec.Type.Date)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Date {
        // message fields
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Date.format)
        pub format: ::std::string::String,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Date.min)
        pub min: ::std::string::String,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Date.max)
        pub max: ::std::string::String,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Date.possible_values)
        pub possible_values: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Date.base)
        pub base: ::protobuf::EnumOrUnknown<date::Base>,
        // special fields
        // @@protoc_insertion_point(special_field:sarus_data_spec.Type.Date.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Date {
        fn default() -> &'a Date {
            <Date as ::protobuf::Message>::default_instance()
        }
    }

    impl Date {
        pub fn new() -> Date {
            ::std::default::Default::default()
        }

        // string format = 1;

        pub fn format(&self) -> &str {
            &self.format
        }

        pub fn clear_format(&mut self) {
            self.format.clear();
        }

        // Param is passed by value, moved
        pub fn set_format(&mut self, v: ::std::string::String) {
            self.format = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_format(&mut self) -> &mut ::std::string::String {
            &mut self.format
        }

        // Take field
        pub fn take_format(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.format, ::std::string::String::new())
        }

        // string min = 2;

        pub fn min(&self) -> &str {
            &self.min
        }

        pub fn clear_min(&mut self) {
            self.min.clear();
        }

        // Param is passed by value, moved
        pub fn set_min(&mut self, v: ::std::string::String) {
            self.min = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_min(&mut self) -> &mut ::std::string::String {
            &mut self.min
        }

        // Take field
        pub fn take_min(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.min, ::std::string::String::new())
        }

        // string max = 3;

        pub fn max(&self) -> &str {
            &self.max
        }

        pub fn clear_max(&mut self) {
            self.max.clear();
        }

        // Param is passed by value, moved
        pub fn set_max(&mut self, v: ::std::string::String) {
            self.max = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_max(&mut self) -> &mut ::std::string::String {
            &mut self.max
        }

        // Take field
        pub fn take_max(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.max, ::std::string::String::new())
        }

        // repeated string possible_values = 4;

        pub fn possible_values(&self) -> &[::std::string::String] {
            &self.possible_values
        }

        pub fn clear_possible_values(&mut self) {
            self.possible_values.clear();
        }

        // Param is passed by value, moved
        pub fn set_possible_values(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.possible_values = v;
        }

        // Mutable pointer to the field.
        pub fn mut_possible_values(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.possible_values
        }

        // Take field
        pub fn take_possible_values(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.possible_values, ::std::vec::Vec::new())
        }

        // .sarus_data_spec.Type.Date.Base base = 5;

        pub fn base(&self) -> date::Base {
            self.base.enum_value_or_default()
        }

        pub fn clear_base(&mut self) {
            self.base = ::protobuf::EnumOrUnknown::new(date::Base::INT32);
        }

        // Param is passed by value, moved
        pub fn set_base(&mut self, v: date::Base) {
            self.base = ::protobuf::EnumOrUnknown::new(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "format",
                |m: &Date| { &m.format },
                |m: &mut Date| { &mut m.format },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "min",
                |m: &Date| { &m.min },
                |m: &mut Date| { &mut m.min },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "max",
                |m: &Date| { &m.max },
                |m: &mut Date| { &mut m.max },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "possible_values",
                |m: &Date| { &m.possible_values },
                |m: &mut Date| { &mut m.possible_values },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "base",
                |m: &Date| { &m.base },
                |m: &mut Date| { &mut m.base },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Date>(
                "Type.Date",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Date {
        const NAME: &'static str = "Date";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.format = is.read_string()?;
                    },
                    18 => {
                        self.min = is.read_string()?;
                    },
                    26 => {
                        self.max = is.read_string()?;
                    },
                    34 => {
                        self.possible_values.push(is.read_string()?);
                    },
                    40 => {
                        self.base = is.read_enum_or_unknown()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.format.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.format);
            }
            if !self.min.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.min);
            }
            if !self.max.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.max);
            }
            for value in &self.possible_values {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            if self.base != ::protobuf::EnumOrUnknown::new(date::Base::INT32) {
                my_size += ::protobuf::rt::int32_size(5, self.base.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.format.is_empty() {
                os.write_string(1, &self.format)?;
            }
            if !self.min.is_empty() {
                os.write_string(2, &self.min)?;
            }
            if !self.max.is_empty() {
                os.write_string(3, &self.max)?;
            }
            for v in &self.possible_values {
                os.write_string(4, &v)?;
            };
            if self.base != ::protobuf::EnumOrUnknown::new(date::Base::INT32) {
                os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.base))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Date {
            Date::new()
        }

        fn clear(&mut self) {
            self.format.clear();
            self.min.clear();
            self.max.clear();
            self.possible_values.clear();
            self.base = ::protobuf::EnumOrUnknown::new(date::Base::INT32);
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Date {
            static instance: Date = Date {
                format: ::std::string::String::new(),
                min: ::std::string::String::new(),
                max: ::std::string::String::new(),
                possible_values: ::std::vec::Vec::new(),
                base: ::protobuf::EnumOrUnknown::from_i32(0),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Date {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Type.Date").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Date {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Date {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Date`
    pub mod date {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:sarus_data_spec.Type.Date.Base)
        pub enum Base {
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Date.Base.INT32)
            INT32 = 0,
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Date.Base.STRING)
            STRING = 1,
        }

        impl ::protobuf::Enum for Base {
            const NAME: &'static str = "Base";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Base> {
                match value {
                    0 => ::std::option::Option::Some(Base::INT32),
                    1 => ::std::option::Option::Some(Base::STRING),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<Base> {
                match str {
                    "INT32" => ::std::option::Option::Some(Base::INT32),
                    "STRING" => ::std::option::Option::Some(Base::STRING),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Base] = &[
                Base::INT32,
                Base::STRING,
            ];
        }

        impl ::protobuf::EnumFull for Base {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("Type.Date.Base").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for Base {
            fn default() -> Self {
                Base::INT32
            }
        }

        impl Base {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Base>("Type.Date.Base")
            }
        }
    }

    // @@protoc_insertion_point(message:sarus_data_spec.Type.Time)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Time {
        // message fields
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Time.format)
        pub format: ::std::string::String,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Time.min)
        pub min: ::std::string::String,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Time.max)
        pub max: ::std::string::String,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Time.possible_values)
        pub possible_values: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Time.base)
        pub base: ::protobuf::EnumOrUnknown<time::Base>,
        // special fields
        // @@protoc_insertion_point(special_field:sarus_data_spec.Type.Time.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Time {
        fn default() -> &'a Time {
            <Time as ::protobuf::Message>::default_instance()
        }
    }

    impl Time {
        pub fn new() -> Time {
            ::std::default::Default::default()
        }

        // string format = 1;

        pub fn format(&self) -> &str {
            &self.format
        }

        pub fn clear_format(&mut self) {
            self.format.clear();
        }

        // Param is passed by value, moved
        pub fn set_format(&mut self, v: ::std::string::String) {
            self.format = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_format(&mut self) -> &mut ::std::string::String {
            &mut self.format
        }

        // Take field
        pub fn take_format(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.format, ::std::string::String::new())
        }

        // string min = 2;

        pub fn min(&self) -> &str {
            &self.min
        }

        pub fn clear_min(&mut self) {
            self.min.clear();
        }

        // Param is passed by value, moved
        pub fn set_min(&mut self, v: ::std::string::String) {
            self.min = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_min(&mut self) -> &mut ::std::string::String {
            &mut self.min
        }

        // Take field
        pub fn take_min(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.min, ::std::string::String::new())
        }

        // string max = 3;

        pub fn max(&self) -> &str {
            &self.max
        }

        pub fn clear_max(&mut self) {
            self.max.clear();
        }

        // Param is passed by value, moved
        pub fn set_max(&mut self, v: ::std::string::String) {
            self.max = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_max(&mut self) -> &mut ::std::string::String {
            &mut self.max
        }

        // Take field
        pub fn take_max(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.max, ::std::string::String::new())
        }

        // repeated string possible_values = 4;

        pub fn possible_values(&self) -> &[::std::string::String] {
            &self.possible_values
        }

        pub fn clear_possible_values(&mut self) {
            self.possible_values.clear();
        }

        // Param is passed by value, moved
        pub fn set_possible_values(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.possible_values = v;
        }

        // Mutable pointer to the field.
        pub fn mut_possible_values(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.possible_values
        }

        // Take field
        pub fn take_possible_values(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.possible_values, ::std::vec::Vec::new())
        }

        // .sarus_data_spec.Type.Time.Base base = 5;

        pub fn base(&self) -> time::Base {
            self.base.enum_value_or_default()
        }

        pub fn clear_base(&mut self) {
            self.base = ::protobuf::EnumOrUnknown::new(time::Base::INT64_NS);
        }

        // Param is passed by value, moved
        pub fn set_base(&mut self, v: time::Base) {
            self.base = ::protobuf::EnumOrUnknown::new(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "format",
                |m: &Time| { &m.format },
                |m: &mut Time| { &mut m.format },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "min",
                |m: &Time| { &m.min },
                |m: &mut Time| { &mut m.min },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "max",
                |m: &Time| { &m.max },
                |m: &mut Time| { &mut m.max },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "possible_values",
                |m: &Time| { &m.possible_values },
                |m: &mut Time| { &mut m.possible_values },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "base",
                |m: &Time| { &m.base },
                |m: &mut Time| { &mut m.base },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Time>(
                "Type.Time",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Time {
        const NAME: &'static str = "Time";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.format = is.read_string()?;
                    },
                    18 => {
                        self.min = is.read_string()?;
                    },
                    26 => {
                        self.max = is.read_string()?;
                    },
                    34 => {
                        self.possible_values.push(is.read_string()?);
                    },
                    40 => {
                        self.base = is.read_enum_or_unknown()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.format.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.format);
            }
            if !self.min.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.min);
            }
            if !self.max.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.max);
            }
            for value in &self.possible_values {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            if self.base != ::protobuf::EnumOrUnknown::new(time::Base::INT64_NS) {
                my_size += ::protobuf::rt::int32_size(5, self.base.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.format.is_empty() {
                os.write_string(1, &self.format)?;
            }
            if !self.min.is_empty() {
                os.write_string(2, &self.min)?;
            }
            if !self.max.is_empty() {
                os.write_string(3, &self.max)?;
            }
            for v in &self.possible_values {
                os.write_string(4, &v)?;
            };
            if self.base != ::protobuf::EnumOrUnknown::new(time::Base::INT64_NS) {
                os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.base))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Time {
            Time::new()
        }

        fn clear(&mut self) {
            self.format.clear();
            self.min.clear();
            self.max.clear();
            self.possible_values.clear();
            self.base = ::protobuf::EnumOrUnknown::new(time::Base::INT64_NS);
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Time {
            static instance: Time = Time {
                format: ::std::string::String::new(),
                min: ::std::string::String::new(),
                max: ::std::string::String::new(),
                possible_values: ::std::vec::Vec::new(),
                base: ::protobuf::EnumOrUnknown::from_i32(0),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Time {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Type.Time").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Time {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Time {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Time`
    pub mod time {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:sarus_data_spec.Type.Time.Base)
        pub enum Base {
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Time.Base.INT64_NS)
            INT64_NS = 0,
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Time.Base.INT32_MS)
            INT32_MS = 1,
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Time.Base.STRING)
            STRING = 2,
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Time.Base.INT64_US)
            INT64_US = 3,
        }

        impl ::protobuf::Enum for Base {
            const NAME: &'static str = "Base";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Base> {
                match value {
                    0 => ::std::option::Option::Some(Base::INT64_NS),
                    1 => ::std::option::Option::Some(Base::INT32_MS),
                    2 => ::std::option::Option::Some(Base::STRING),
                    3 => ::std::option::Option::Some(Base::INT64_US),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<Base> {
                match str {
                    "INT64_NS" => ::std::option::Option::Some(Base::INT64_NS),
                    "INT32_MS" => ::std::option::Option::Some(Base::INT32_MS),
                    "STRING" => ::std::option::Option::Some(Base::STRING),
                    "INT64_US" => ::std::option::Option::Some(Base::INT64_US),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Base] = &[
                Base::INT64_NS,
                Base::INT32_MS,
                Base::STRING,
                Base::INT64_US,
            ];
        }

        impl ::protobuf::EnumFull for Base {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("Type.Time.Base").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for Base {
            fn default() -> Self {
                Base::INT64_NS
            }
        }

        impl Base {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Base>("Type.Time.Base")
            }
        }
    }

    // @@protoc_insertion_point(message:sarus_data_spec.Type.Duration)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Duration {
        // message fields
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Duration.unit)
        pub unit: ::std::string::String,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Duration.min)
        pub min: i64,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Duration.max)
        pub max: i64,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Duration.possible_values)
        pub possible_values: ::std::vec::Vec<i64>,
        // special fields
        // @@protoc_insertion_point(special_field:sarus_data_spec.Type.Duration.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Duration {
        fn default() -> &'a Duration {
            <Duration as ::protobuf::Message>::default_instance()
        }
    }

    impl Duration {
        pub fn new() -> Duration {
            ::std::default::Default::default()
        }

        // string unit = 1;

        pub fn unit(&self) -> &str {
            &self.unit
        }

        pub fn clear_unit(&mut self) {
            self.unit.clear();
        }

        // Param is passed by value, moved
        pub fn set_unit(&mut self, v: ::std::string::String) {
            self.unit = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_unit(&mut self) -> &mut ::std::string::String {
            &mut self.unit
        }

        // Take field
        pub fn take_unit(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.unit, ::std::string::String::new())
        }

        // int64 min = 2;

        pub fn min(&self) -> i64 {
            self.min
        }

        pub fn clear_min(&mut self) {
            self.min = 0;
        }

        // Param is passed by value, moved
        pub fn set_min(&mut self, v: i64) {
            self.min = v;
        }

        // int64 max = 3;

        pub fn max(&self) -> i64 {
            self.max
        }

        pub fn clear_max(&mut self) {
            self.max = 0;
        }

        // Param is passed by value, moved
        pub fn set_max(&mut self, v: i64) {
            self.max = v;
        }

        // repeated int64 possible_values = 4;

        pub fn possible_values(&self) -> &[i64] {
            &self.possible_values
        }

        pub fn clear_possible_values(&mut self) {
            self.possible_values.clear();
        }

        // Param is passed by value, moved
        pub fn set_possible_values(&mut self, v: ::std::vec::Vec<i64>) {
            self.possible_values = v;
        }

        // Mutable pointer to the field.
        pub fn mut_possible_values(&mut self) -> &mut ::std::vec::Vec<i64> {
            &mut self.possible_values
        }

        // Take field
        pub fn take_possible_values(&mut self) -> ::std::vec::Vec<i64> {
            ::std::mem::replace(&mut self.possible_values, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "unit",
                |m: &Duration| { &m.unit },
                |m: &mut Duration| { &mut m.unit },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "min",
                |m: &Duration| { &m.min },
                |m: &mut Duration| { &mut m.min },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "max",
                |m: &Duration| { &m.max },
                |m: &mut Duration| { &mut m.max },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "possible_values",
                |m: &Duration| { &m.possible_values },
                |m: &mut Duration| { &mut m.possible_values },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Duration>(
                "Type.Duration",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Duration {
        const NAME: &'static str = "Duration";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.unit = is.read_string()?;
                    },
                    16 => {
                        self.min = is.read_int64()?;
                    },
                    24 => {
                        self.max = is.read_int64()?;
                    },
                    34 => {
                        is.read_repeated_packed_int64_into(&mut self.possible_values)?;
                    },
                    32 => {
                        self.possible_values.push(is.read_int64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.unit.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.unit);
            }
            if self.min != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.min);
            }
            if self.max != 0 {
                my_size += ::protobuf::rt::int64_size(3, self.max);
            }
            for value in &self.possible_values {
                my_size += ::protobuf::rt::int64_size(4, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.unit.is_empty() {
                os.write_string(1, &self.unit)?;
            }
            if self.min != 0 {
                os.write_int64(2, self.min)?;
            }
            if self.max != 0 {
                os.write_int64(3, self.max)?;
            }
            for v in &self.possible_values {
                os.write_int64(4, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Duration {
            Duration::new()
        }

        fn clear(&mut self) {
            self.unit.clear();
            self.min = 0;
            self.max = 0;
            self.possible_values.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Duration {
            static instance: Duration = Duration {
                unit: ::std::string::String::new(),
                min: 0,
                max: 0,
                possible_values: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Duration {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Type.Duration").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Duration {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Duration {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:sarus_data_spec.Type.Constrained)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Constrained {
        // message fields
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Constrained.type)
        pub type_: ::protobuf::MessageField<super::Type>,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Constrained.constraint)
        pub constraint: ::protobuf::MessageField<super::super::predicate::Predicate>,
        // special fields
        // @@protoc_insertion_point(special_field:sarus_data_spec.Type.Constrained.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Constrained {
        fn default() -> &'a Constrained {
            <Constrained as ::protobuf::Message>::default_instance()
        }
    }

    impl Constrained {
        pub fn new() -> Constrained {
            ::std::default::Default::default()
        }

        // .sarus_data_spec.Type type = 1;

        pub fn type_(&self) -> &super::Type {
            self.type_.as_ref().unwrap_or_else(|| <super::Type as ::protobuf::Message>::default_instance())
        }

        pub fn clear_type_(&mut self) {
            self.type_.clear();
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: super::Type) {
            self.type_ = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_type(&mut self) -> &mut super::Type {
            self.type_.mut_or_insert_default()
        }

        // Take field
        pub fn take_type_(&mut self) -> super::Type {
            self.type_.take().unwrap_or_else(|| super::Type::new())
        }

        // .sarus_data_spec.Predicate constraint = 2;

        pub fn constraint(&self) -> &super::super::predicate::Predicate {
            self.constraint.as_ref().unwrap_or_else(|| <super::super::predicate::Predicate as ::protobuf::Message>::default_instance())
        }

        pub fn clear_constraint(&mut self) {
            self.constraint.clear();
        }

        pub fn has_constraint(&self) -> bool {
            self.constraint.is_some()
        }

        // Param is passed by value, moved
        pub fn set_constraint(&mut self, v: super::super::predicate::Predicate) {
            self.constraint = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_constraint(&mut self) -> &mut super::super::predicate::Predicate {
            self.constraint.mut_or_insert_default()
        }

        // Take field
        pub fn take_constraint(&mut self) -> super::super::predicate::Predicate {
            self.constraint.take().unwrap_or_else(|| super::super::predicate::Predicate::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Type>(
                "type",
                |m: &Constrained| { &m.type_ },
                |m: &mut Constrained| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::predicate::Predicate>(
                "constraint",
                |m: &Constrained| { &m.constraint },
                |m: &mut Constrained| { &mut m.constraint },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Constrained>(
                "Type.Constrained",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Constrained {
        const NAME: &'static str = "Constrained";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.type_)?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.constraint)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.constraint.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.constraint.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Constrained {
            Constrained::new()
        }

        fn clear(&mut self) {
            self.type_.clear();
            self.constraint.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Constrained {
            static instance: Constrained = Constrained {
                type_: ::protobuf::MessageField::none(),
                constraint: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Constrained {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Type.Constrained").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Constrained {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Constrained {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:sarus_data_spec.Type.Hypothesis)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Hypothesis {
        // message fields
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Hypothesis.types)
        pub types: ::std::vec::Vec<hypothesis::Scored>,
        // special fields
        // @@protoc_insertion_point(special_field:sarus_data_spec.Type.Hypothesis.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Hypothesis {
        fn default() -> &'a Hypothesis {
            <Hypothesis as ::protobuf::Message>::default_instance()
        }
    }

    impl Hypothesis {
        pub fn new() -> Hypothesis {
            ::std::default::Default::default()
        }

        // repeated .sarus_data_spec.Type.Hypothesis.Scored types = 2;

        pub fn types(&self) -> &[hypothesis::Scored] {
            &self.types
        }

        pub fn clear_types(&mut self) {
            self.types.clear();
        }

        // Param is passed by value, moved
        pub fn set_types(&mut self, v: ::std::vec::Vec<hypothesis::Scored>) {
            self.types = v;
        }

        // Mutable pointer to the field.
        pub fn mut_types(&mut self) -> &mut ::std::vec::Vec<hypothesis::Scored> {
            &mut self.types
        }

        // Take field
        pub fn take_types(&mut self) -> ::std::vec::Vec<hypothesis::Scored> {
            ::std::mem::replace(&mut self.types, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "types",
                |m: &Hypothesis| { &m.types },
                |m: &mut Hypothesis| { &mut m.types },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Hypothesis>(
                "Type.Hypothesis",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Hypothesis {
        const NAME: &'static str = "Hypothesis";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    18 => {
                        self.types.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.types {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.types {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Hypothesis {
            Hypothesis::new()
        }

        fn clear(&mut self) {
            self.types.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Hypothesis {
            static instance: Hypothesis = Hypothesis {
                types: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Hypothesis {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Type.Hypothesis").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Hypothesis {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Hypothesis {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Hypothesis`
    pub mod hypothesis {
        // @@protoc_insertion_point(message:sarus_data_spec.Type.Hypothesis.Scored)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Scored {
            // message fields
            // @@protoc_insertion_point(field:sarus_data_spec.Type.Hypothesis.Scored.type)
            pub type_: ::protobuf::MessageField<super::super::Type>,
            // @@protoc_insertion_point(field:sarus_data_spec.Type.Hypothesis.Scored.score)
            pub score: f64,
            // special fields
            // @@protoc_insertion_point(special_field:sarus_data_spec.Type.Hypothesis.Scored.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Scored {
            fn default() -> &'a Scored {
                <Scored as ::protobuf::Message>::default_instance()
            }
        }

        impl Scored {
            pub fn new() -> Scored {
                ::std::default::Default::default()
            }

            // .sarus_data_spec.Type type = 1;

            pub fn type_(&self) -> &super::super::Type {
                self.type_.as_ref().unwrap_or_else(|| <super::super::Type as ::protobuf::Message>::default_instance())
            }

            pub fn clear_type_(&mut self) {
                self.type_.clear();
            }

            pub fn has_type(&self) -> bool {
                self.type_.is_some()
            }

            // Param is passed by value, moved
            pub fn set_type(&mut self, v: super::super::Type) {
                self.type_ = ::protobuf::MessageField::some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_type(&mut self) -> &mut super::super::Type {
                self.type_.mut_or_insert_default()
            }

            // Take field
            pub fn take_type_(&mut self) -> super::super::Type {
                self.type_.take().unwrap_or_else(|| super::super::Type::new())
            }

            // double score = 2;

            pub fn score(&self) -> f64 {
                self.score
            }

            pub fn clear_score(&mut self) {
                self.score = 0.;
            }

            // Param is passed by value, moved
            pub fn set_score(&mut self, v: f64) {
                self.score = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::Type>(
                    "type",
                    |m: &Scored| { &m.type_ },
                    |m: &mut Scored| { &mut m.type_ },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "score",
                    |m: &Scored| { &m.score },
                    |m: &mut Scored| { &mut m.score },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Scored>(
                    "Type.Hypothesis.Scored",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Scored {
            const NAME: &'static str = "Scored";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.type_)?;
                        },
                        17 => {
                            self.score = is.read_double()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.type_.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                if self.score != 0. {
                    my_size += 1 + 8;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.type_.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                }
                if self.score != 0. {
                    os.write_double(2, self.score)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Scored {
                Scored::new()
            }

            fn clear(&mut self) {
                self.type_.clear();
                self.score = 0.;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Scored {
                static instance: Scored = Scored {
                    type_: ::protobuf::MessageField::none(),
                    score: 0.,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Scored {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Type.Hypothesis.Scored").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Scored {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Scored {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:sarus_data_spec.Type.Id)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Id {
        // message fields
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Id.base)
        pub base: ::protobuf::EnumOrUnknown<id::Base>,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Id.unique)
        pub unique: bool,
        // @@protoc_insertion_point(field:sarus_data_spec.Type.Id.reference)
        pub reference: ::protobuf::MessageField<super::super::path::Path>,
        // special fields
        // @@protoc_insertion_point(special_field:sarus_data_spec.Type.Id.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Id {
        fn default() -> &'a Id {
            <Id as ::protobuf::Message>::default_instance()
        }
    }

    impl Id {
        pub fn new() -> Id {
            ::std::default::Default::default()
        }

        // .sarus_data_spec.Type.Id.Base base = 1;

        pub fn base(&self) -> id::Base {
            self.base.enum_value_or_default()
        }

        pub fn clear_base(&mut self) {
            self.base = ::protobuf::EnumOrUnknown::new(id::Base::INT64);
        }

        // Param is passed by value, moved
        pub fn set_base(&mut self, v: id::Base) {
            self.base = ::protobuf::EnumOrUnknown::new(v);
        }

        // bool unique = 2;

        pub fn unique(&self) -> bool {
            self.unique
        }

        pub fn clear_unique(&mut self) {
            self.unique = false;
        }

        // Param is passed by value, moved
        pub fn set_unique(&mut self, v: bool) {
            self.unique = v;
        }

        // .sarus_data_spec.Path reference = 3;

        pub fn reference(&self) -> &super::super::path::Path {
            self.reference.as_ref().unwrap_or_else(|| <super::super::path::Path as ::protobuf::Message>::default_instance())
        }

        pub fn clear_reference(&mut self) {
            self.reference.clear();
        }

        pub fn has_reference(&self) -> bool {
            self.reference.is_some()
        }

        // Param is passed by value, moved
        pub fn set_reference(&mut self, v: super::super::path::Path) {
            self.reference = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_reference(&mut self) -> &mut super::super::path::Path {
            self.reference.mut_or_insert_default()
        }

        // Take field
        pub fn take_reference(&mut self) -> super::super::path::Path {
            self.reference.take().unwrap_or_else(|| super::super::path::Path::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "base",
                |m: &Id| { &m.base },
                |m: &mut Id| { &mut m.base },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "unique",
                |m: &Id| { &m.unique },
                |m: &mut Id| { &mut m.unique },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::path::Path>(
                "reference",
                |m: &Id| { &m.reference },
                |m: &mut Id| { &mut m.reference },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Id>(
                "Type.Id",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Id {
        const NAME: &'static str = "Id";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.base = is.read_enum_or_unknown()?;
                    },
                    16 => {
                        self.unique = is.read_bool()?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.reference)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.base != ::protobuf::EnumOrUnknown::new(id::Base::INT64) {
                my_size += ::protobuf::rt::int32_size(1, self.base.value());
            }
            if self.unique != false {
                my_size += 1 + 1;
            }
            if let Some(v) = self.reference.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.base != ::protobuf::EnumOrUnknown::new(id::Base::INT64) {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.base))?;
            }
            if self.unique != false {
                os.write_bool(2, self.unique)?;
            }
            if let Some(v) = self.reference.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Id {
            Id::new()
        }

        fn clear(&mut self) {
            self.base = ::protobuf::EnumOrUnknown::new(id::Base::INT64);
            self.unique = false;
            self.reference.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Id {
            static instance: Id = Id {
                base: ::protobuf::EnumOrUnknown::from_i32(0),
                unique: false,
                reference: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Id {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Type.Id").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Id {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Id {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Id`
    pub mod id {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:sarus_data_spec.Type.Id.Base)
        pub enum Base {
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Id.Base.INT64)
            INT64 = 0,
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Id.Base.INT32)
            INT32 = 1,
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Id.Base.INT16)
            INT16 = 2,
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Id.Base.INT8)
            INT8 = 3,
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Id.Base.STRING)
            STRING = 4,
            // @@protoc_insertion_point(enum_value:sarus_data_spec.Type.Id.Base.BYTES)
            BYTES = 5,
        }

        impl ::protobuf::Enum for Base {
            const NAME: &'static str = "Base";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Base> {
                match value {
                    0 => ::std::option::Option::Some(Base::INT64),
                    1 => ::std::option::Option::Some(Base::INT32),
                    2 => ::std::option::Option::Some(Base::INT16),
                    3 => ::std::option::Option::Some(Base::INT8),
                    4 => ::std::option::Option::Some(Base::STRING),
                    5 => ::std::option::Option::Some(Base::BYTES),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<Base> {
                match str {
                    "INT64" => ::std::option::Option::Some(Base::INT64),
                    "INT32" => ::std::option::Option::Some(Base::INT32),
                    "INT16" => ::std::option::Option::Some(Base::INT16),
                    "INT8" => ::std::option::Option::Some(Base::INT8),
                    "STRING" => ::std::option::Option::Some(Base::STRING),
                    "BYTES" => ::std::option::Option::Some(Base::BYTES),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Base] = &[
                Base::INT64,
                Base::INT32,
                Base::INT16,
                Base::INT8,
                Base::STRING,
                Base::BYTES,
            ];
        }

        impl ::protobuf::EnumFull for Base {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("Type.Id.Base").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for Base {
            fn default() -> Self {
                Base::INT64
            }
        }

        impl Base {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Base>("Type.Id.Base")
            }
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n#sarus_data_spec/protobuf/type.proto\x12\x0fsarus_data_spec\x1a(sarus_\
    data_spec/protobuf/predicate.proto\x1a#sarus_data_spec/protobuf/path.pro\
    to\"\xd8\x1d\n\x04Type\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\
    0\n\x04null\x18\x03\x20\x01(\x0b2\x1a.sarus_data_spec.Type.NullH\0R\x04n\
    ull\x120\n\x04unit\x18\x04\x20\x01(\x0b2\x1a.sarus_data_spec.Type.UnitH\
    \0R\x04unit\x129\n\x07boolean\x18\x05\x20\x01(\x0b2\x1d.sarus_data_spec.\
    Type.BooleanH\0R\x07boolean\x129\n\x07integer\x18\x06\x20\x01(\x0b2\x1d.\
    sarus_data_spec.Type.IntegerH\0R\x07integer\x120\n\x04enum\x18\x07\x20\
    \x01(\x0b2\x1a.sarus_data_spec.Type.EnumH\0R\x04enum\x123\n\x05float\x18\
    \x08\x20\x01(\x0b2\x1b.sarus_data_spec.Type.FloatH\0R\x05float\x120\n\
    \x04text\x18\t\x20\x01(\x0b2\x1a.sarus_data_spec.Type.TextH\0R\x04text\
    \x123\n\x05bytes\x18\n\x20\x01(\x0b2\x1b.sarus_data_spec.Type.BytesH\0R\
    \x05bytes\x126\n\x06struct\x18\x0b\x20\x01(\x0b2\x1c.sarus_data_spec.Typ\
    e.StructH\0R\x06struct\x123\n\x05union\x18\x0c\x20\x01(\x0b2\x1b.sarus_d\
    ata_spec.Type.UnionH\0R\x05union\x12<\n\x08optional\x18\r\x20\x01(\x0b2\
    \x1e.sarus_data_spec.Type.OptionalH\0R\x08optional\x120\n\x04list\x18\
    \x0e\x20\x01(\x0b2\x1a.sarus_data_spec.Type.ListH\0R\x04list\x123\n\x05a\
    rray\x18\x0f\x20\x01(\x0b2\x1b.sarus_data_spec.Type.ArrayH\0R\x05array\
    \x12<\n\x08datetime\x18\x10\x20\x01(\x0b2\x1e.sarus_data_spec.Type.Datet\
    imeH\0R\x08datetime\x12E\n\x0bconstrained\x18\x11\x20\x01(\x0b2!.sarus_d\
    ata_spec.Type.ConstrainedH\0R\x0bconstrained\x12B\n\nhypothesis\x18\x12\
    \x20\x01(\x0b2\x20.sarus_data_spec.Type.HypothesisH\0R\nhypothesis\x12*\
    \n\x02id\x18\x13\x20\x01(\x0b2\x18.sarus_data_spec.Type.IdH\0R\x02id\x12\
    0\n\x04date\x18\x14\x20\x01(\x0b2\x1a.sarus_data_spec.Type.DateH\0R\x04d\
    ate\x120\n\x04time\x18\x15\x20\x01(\x0b2\x1a.sarus_data_spec.Type.TimeH\
    \0R\x04time\x12<\n\x08duration\x18\x16\x20\x01(\x0b2\x1e.sarus_data_spec\
    .Type.DurationH\0R\x08duration\x12E\n\nproperties\x18\x02\x20\x03(\x0b2%\
    .sarus_data_spec.Type.PropertiesEntryR\nproperties\x1a=\n\x0fPropertiesE\
    ntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\x1a\x06\n\x04Null\x1a\x06\n\x04Unit\
    \x1a\t\n\x07Boolean\x1a\xf0\x01\n\x07Integer\x126\n\x04base\x18\x01\x20\
    \x01(\x0e2\".sarus_data_spec.Type.Integer.BaseR\x04base\x12\x10\n\x03min\
    \x18\x02\x20\x01(\x03R\x03min\x12\x10\n\x03max\x18\x03\x20\x01(\x03R\x03\
    max\x12'\n\x0fpossible_values\x18\x04\x20\x03(\x03R\x0epossibleValues\"`\
    \n\x04Base\x12\t\n\x05INT64\x10\0\x12\t\n\x05INT32\x10\x01\x12\t\n\x05IN\
    T16\x10\x02\x12\x08\n\x04INT8\x10\x03\x12\n\n\x06UINT64\x10\x04\x12\n\n\
    \x06UINT32\x10\x05\x12\n\n\x06UINT16\x10\x06\x12\t\n\x05UINT8\x10\x07\
    \x1a\x86\x02\n\x04Enum\x123\n\x04base\x18\x01\x20\x01(\x0e2\x1f.sarus_da\
    ta_spec.Type.Enum.BaseR\x04base\x12\x18\n\x07ordered\x18\x02\x20\x01(\
    \x08R\x07ordered\x12E\n\x0bname_values\x18\x03\x20\x03(\x0b2$.sarus_data\
    _spec.Type.Enum.NameValueR\nnameValues\x1a5\n\tNameValue\x12\x12\n\x04na\
    me\x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\x02\x20\x01(\x03R\
    \x05value\"1\n\x04Base\x12\t\n\x05INT64\x10\0\x12\t\n\x05INT32\x10\x01\
    \x12\t\n\x05INT16\x10\x02\x12\x08\n\x04INT8\x10\x03\x1a\xb9\x01\n\x05Flo\
    at\x124\n\x04base\x18\x01\x20\x01(\x0e2\x20.sarus_data_spec.Type.Float.B\
    aseR\x04base\x12\x10\n\x03min\x18\x02\x20\x01(\x01R\x03min\x12\x10\n\x03\
    max\x18\x03\x20\x01(\x01R\x03max\x12'\n\x0fpossible_values\x18\x04\x20\
    \x03(\x01R\x0epossibleValues\"-\n\x04Base\x12\x0b\n\x07FLOAT64\x10\0\x12\
    \x0b\n\x07FLOAT32\x10\x01\x12\x0b\n\x07FLOAT16\x10\x02\x1aK\n\x04Text\
    \x12\x1a\n\x08encoding\x18\x01\x20\x01(\tR\x08encoding\x12'\n\x0fpossibl\
    e_values\x18\x02\x20\x03(\tR\x0epossibleValues\x1a\x07\n\x05Bytes\x1a\
    \x8c\x01\n\x06Struct\x12:\n\x06fields\x18\x01\x20\x03(\x0b2\".sarus_data\
    _spec.Type.Struct.FieldR\x06fields\x1aF\n\x05Field\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12)\n\x04type\x18\x02\x20\x01(\x0b2\x15.sarus_\
    data_spec.TypeR\x04type\x1a\x8a\x01\n\x05Union\x129\n\x06fields\x18\x01\
    \x20\x03(\x0b2!.sarus_data_spec.Type.Union.FieldR\x06fields\x1aF\n\x05Fi\
    eld\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12)\n\x04type\x18\x02\
    \x20\x01(\x0b2\x15.sarus_data_spec.TypeR\x04type\x1a5\n\x08Optional\x12)\
    \n\x04type\x18\x01\x20\x01(\x0b2\x15.sarus_data_spec.TypeR\x04type\x1aL\
    \n\x04List\x12)\n\x04type\x18\x01\x20\x01(\x0b2\x15.sarus_data_spec.Type\
    R\x04type\x12\x19\n\x08max_size\x18\x02\x20\x01(\x03R\x07maxSize\x1aH\n\
    \x05Array\x12)\n\x04type\x18\x01\x20\x01(\x0b2\x15.sarus_data_spec.TypeR\
    \x04type\x12\x14\n\x05shape\x18\x02\x20\x03(\x03R\x05shape\x1a\xd8\x01\n\
    \x08Datetime\x12\x16\n\x06format\x18\x01\x20\x01(\tR\x06format\x12\x10\n\
    \x03min\x18\x02\x20\x01(\tR\x03min\x12\x10\n\x03max\x18\x03\x20\x01(\tR\
    \x03max\x12'\n\x0fpossible_values\x18\x04\x20\x03(\tR\x0epossibleValues\
    \x127\n\x04base\x18\x05\x20\x01(\x0e2#.sarus_data_spec.Type.Datetime.Bas\
    eR\x04base\".\n\x04Base\x12\x0c\n\x08INT64_NS\x10\0\x12\x0c\n\x08INT64_M\
    S\x10\x01\x12\n\n\x06STRING\x10\x02\x1a\xbf\x01\n\x04Date\x12\x16\n\x06f\
    ormat\x18\x01\x20\x01(\tR\x06format\x12\x10\n\x03min\x18\x02\x20\x01(\tR\
    \x03min\x12\x10\n\x03max\x18\x03\x20\x01(\tR\x03max\x12'\n\x0fpossible_v\
    alues\x18\x04\x20\x03(\tR\x0epossibleValues\x123\n\x04base\x18\x05\x20\
    \x01(\x0e2\x1f.sarus_data_spec.Type.Date.BaseR\x04base\"\x1d\n\x04Base\
    \x12\t\n\x05INT32\x10\0\x12\n\n\x06STRING\x10\x01\x1a\xde\x01\n\x04Time\
    \x12\x16\n\x06format\x18\x01\x20\x01(\tR\x06format\x12\x10\n\x03min\x18\
    \x02\x20\x01(\tR\x03min\x12\x10\n\x03max\x18\x03\x20\x01(\tR\x03max\x12'\
    \n\x0fpossible_values\x18\x04\x20\x03(\tR\x0epossibleValues\x123\n\x04ba\
    se\x18\x05\x20\x01(\x0e2\x1f.sarus_data_spec.Type.Time.BaseR\x04base\"<\
    \n\x04Base\x12\x0c\n\x08INT64_NS\x10\0\x12\x0c\n\x08INT32_MS\x10\x01\x12\
    \n\n\x06STRING\x10\x02\x12\x0c\n\x08INT64_US\x10\x03\x1ak\n\x08Duration\
    \x12\x12\n\x04unit\x18\x01\x20\x01(\tR\x04unit\x12\x10\n\x03min\x18\x02\
    \x20\x01(\x03R\x03min\x12\x10\n\x03max\x18\x03\x20\x01(\x03R\x03max\x12'\
    \n\x0fpossible_values\x18\x04\x20\x03(\x03R\x0epossibleValues\x1at\n\x0b\
    Constrained\x12)\n\x04type\x18\x01\x20\x01(\x0b2\x15.sarus_data_spec.Typ\
    eR\x04type\x12:\n\nconstraint\x18\x02\x20\x01(\x0b2\x1a.sarus_data_spec.\
    PredicateR\nconstraint\x1a\x96\x01\n\nHypothesis\x12=\n\x05types\x18\x02\
    \x20\x03(\x0b2'.sarus_data_spec.Type.Hypothesis.ScoredR\x05types\x1aI\n\
    \x06Scored\x12)\n\x04type\x18\x01\x20\x01(\x0b2\x15.sarus_data_spec.Type\
    R\x04type\x12\x14\n\x05score\x18\x02\x20\x01(\x01R\x05score\x1a\xce\x01\
    \n\x02Id\x121\n\x04base\x18\x01\x20\x01(\x0e2\x1d.sarus_data_spec.Type.I\
    d.BaseR\x04base\x12\x16\n\x06unique\x18\x02\x20\x01(\x08R\x06unique\x123\
    \n\treference\x18\x03\x20\x01(\x0b2\x15.sarus_data_spec.PathR\treference\
    \"H\n\x04Base\x12\t\n\x05INT64\x10\0\x12\t\n\x05INT32\x10\x01\x12\t\n\
    \x05INT16\x10\x02\x12\x08\n\x04INT8\x10\x03\x12\n\n\x06STRING\x10\x04\
    \x12\t\n\x05BYTES\x10\x05B\x06\n\x04typeb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::predicate::file_descriptor().clone());
            deps.push(super::path::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(25);
            messages.push(Type::generated_message_descriptor_data());
            messages.push(type_::Null::generated_message_descriptor_data());
            messages.push(type_::Unit::generated_message_descriptor_data());
            messages.push(type_::Boolean::generated_message_descriptor_data());
            messages.push(type_::Integer::generated_message_descriptor_data());
            messages.push(type_::Enum::generated_message_descriptor_data());
            messages.push(type_::Float::generated_message_descriptor_data());
            messages.push(type_::Text::generated_message_descriptor_data());
            messages.push(type_::Bytes::generated_message_descriptor_data());
            messages.push(type_::Struct::generated_message_descriptor_data());
            messages.push(type_::Union::generated_message_descriptor_data());
            messages.push(type_::Optional::generated_message_descriptor_data());
            messages.push(type_::List::generated_message_descriptor_data());
            messages.push(type_::Array::generated_message_descriptor_data());
            messages.push(type_::Datetime::generated_message_descriptor_data());
            messages.push(type_::Date::generated_message_descriptor_data());
            messages.push(type_::Time::generated_message_descriptor_data());
            messages.push(type_::Duration::generated_message_descriptor_data());
            messages.push(type_::Constrained::generated_message_descriptor_data());
            messages.push(type_::Hypothesis::generated_message_descriptor_data());
            messages.push(type_::Id::generated_message_descriptor_data());
            messages.push(type_::enum_::NameValue::generated_message_descriptor_data());
            messages.push(type_::struct_::Field::generated_message_descriptor_data());
            messages.push(type_::union::Field::generated_message_descriptor_data());
            messages.push(type_::hypothesis::Scored::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(7);
            enums.push(type_::integer::Base::generated_enum_descriptor_data());
            enums.push(type_::enum_::Base::generated_enum_descriptor_data());
            enums.push(type_::float::Base::generated_enum_descriptor_data());
            enums.push(type_::datetime::Base::generated_enum_descriptor_data());
            enums.push(type_::date::Base::generated_enum_descriptor_data());
            enums.push(type_::time::Base::generated_enum_descriptor_data());
            enums.push(type_::id::Base::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
